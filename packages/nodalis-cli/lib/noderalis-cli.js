/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
module.exports = /******/ (() => {
	// webpackBootstrap
	/******/ var __webpack_modules__ = {
		/***/ './packages/nodalis-cli/sources/commands/BuildCommand.ts':
			/*!*****************************************************************!*\
  !*** ./packages/nodalis-cli/sources/commands/BuildCommand.ts ***!
  \*****************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BuildCommand = void 0;\nconst core_1 = __webpack_require__(/*! @nodalis/core */ "./packages/nodalis-core/sources/index.ts");\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nconst BaseCommand_1 = __webpack_require__(/*! ../tools/BaseCommand */ "./packages/nodalis-cli/sources/tools/BaseCommand.ts");\nconst cross_spawn_1 = __importDefault(__webpack_require__(/*! cross-spawn */ "./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/index.js"));\n/**\n * Builds projects in parallel using cross-spawn.\n *\n * @todo #3 Instead of using configs, generate them on-demand.\n */\nclass BuildCommand extends BaseCommand_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.isProduction = false;\n        this.watch = false;\n    }\n    async execute() {\n        await core_1.ProjectConfiguration.find();\n        this.context.stdout.write(\'Currently not supported internally, building external solution soon.\');\n        // We still need to generate and write out the custom configuration.\n        cross_spawn_1.default(\'webpack\', [\'--config\', \'webpack.config.ts\']);\n        // const compiler = webpack(\n        //   WebpackConfiguration.createWebpackConfig(this.context)\n        // );\n        // const buildErrors = await new Promise<string | null>((resolve, reject) => {\n        //   compiler.run((error, stats) => {\n        //     if (error) {\n        //       reject(error);\n        //     } else if (stats && stats.compilation.errors.length > 0) {\n        //       resolve(stats.toString(\'errors-only\'));\n        //     } else {\n        //       resolve(null);\n        //     }\n        //   });\n        // });\n        // if (buildErrors) {\n        //   this.context.stdout.write(`Build failed:`);\n        //   this.context.stdout.write(buildErrors);\n        // } else {\n        //   this.context.stdout.write(`Build successful`);\n        // }\n    }\n}\n__decorate([\n    clipanion_1.Command.Boolean(\'prod, p\')\n], BuildCommand.prototype, "isProduction", void 0);\n__decorate([\n    clipanion_1.Command.Boolean(\'watch, w\')\n], BuildCommand.prototype, "watch", void 0);\n__decorate([\n    clipanion_1.Command.Path(\'build\')\n], BuildCommand.prototype, "execute", null);\nexports.BuildCommand = BuildCommand;\nexports.default = BuildCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/commands/BuildCommand.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/commands/GenerateCommand.ts':
			/*!********************************************************************!*\
  !*** ./packages/nodalis-cli/sources/commands/GenerateCommand.ts ***!
  \********************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.GenerateCommand = void 0;\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nconst sources_1 = __webpack_require__(/*! @nodalis/core/sources */ "./packages/nodalis-core/sources/index.ts");\nconst BaseCommand_1 = __webpack_require__(/*! ../tools/BaseCommand */ "./packages/nodalis-cli/sources/tools/BaseCommand.ts");\n/**\n * Generates a new repository from a Nodalis template.\n */\nclass GenerateCommand extends BaseCommand_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.list = false;\n    }\n    // const prompt = inquirer.createPromptModule({\n    //   input: this.context.stdin,\n    //   output: this.context.stdout,\n    // });\n    async execute() {\n        throw new clipanion_1.UsageError(sources_1.notImpl);\n    }\n}\n__decorate([\n    clipanion_1.Command.String(\'--list\', { tolerateBoolean: false })\n], GenerateCommand.prototype, "list", void 0);\n__decorate([\n    clipanion_1.Command.Path(\'generate\'),\n    clipanion_1.Command.Path(\'g\')\n], GenerateCommand.prototype, "execute", null);\nexports.GenerateCommand = GenerateCommand;\nexports.default = GenerateCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/commands/GenerateCommand.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/commands/StartCommand.ts':
			/*!*****************************************************************!*\
  !*** ./packages/nodalis-cli/sources/commands/StartCommand.ts ***!
  \*****************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.StartCommand = void 0;\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nconst sources_1 = __webpack_require__(/*! @nodalis/core/sources */ "./packages/nodalis-core/sources/index.ts");\nconst BaseCommand_1 = __webpack_require__(/*! ../tools/BaseCommand */ "./packages/nodalis-cli/sources/tools/BaseCommand.ts");\n/**\n * Will eventually start a development server.\n */\nclass StartCommand extends BaseCommand_1.BaseCommand {\n    async execute() {\n        this.stdout(this.context.cwd);\n        this.stdout(sources_1.notImpl);\n    }\n}\n__decorate([\n    clipanion_1.Command.Path(\'start\')\n], StartCommand.prototype, "execute", null);\nexports.StartCommand = StartCommand;\nexports.default = StartCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/commands/StartCommand.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/commands/TestCommand.ts':
			/*!****************************************************************!*\
  !*** ./packages/nodalis-cli/sources/commands/TestCommand.ts ***!
  \****************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TestCommand = void 0;\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nconst core_1 = __webpack_require__(/*! @nodalis/core */ "./packages/nodalis-core/sources/index.ts");\nconst BaseCommand_1 = __webpack_require__(/*! ../tools/BaseCommand */ "./packages/nodalis-cli/sources/tools/BaseCommand.ts");\nclass TestCommand extends BaseCommand_1.BaseCommand {\n    async execute() {\n        throw new clipanion_1.UsageError(core_1.notImpl);\n    }\n}\n__decorate([\n    clipanion_1.Command.Path(\'test\')\n], TestCommand.prototype, "execute", null);\nexports.TestCommand = TestCommand;\nexports.default = TestCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/commands/TestCommand.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/commands/WelcomeCommand.ts':
			/*!*******************************************************************!*\
  !*** ./packages/nodalis-cli/sources/commands/WelcomeCommand.ts ***!
  \*******************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WelcomeCommand = void 0;\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nconst BaseCommand_1 = __webpack_require__(/*! ../tools/BaseCommand */ "./packages/nodalis-cli/sources/tools/BaseCommand.ts");\nconst message = () => `\nWelcome to Nodalis! A Node.js application framework!\n\nI won\'t lie, Nodalis uses "arcanis/Clipanion" which is new and not\noverly documented so I stripped some logic from Yarn 2 ðŸ˜….\n`;\nclass WelcomeCommand extends BaseCommand_1.BaseCommand {\n    async execute() {\n        this.context.stdout.write(`${message().trim()}\\n`);\n    }\n}\n__decorate([\n    clipanion_1.Command.Path(\'--welcome\'),\n    clipanion_1.Command.Path()\n], WelcomeCommand.prototype, "execute", null);\nexports.WelcomeCommand = WelcomeCommand;\nexports.default = WelcomeCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/commands/WelcomeCommand.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/commands/commands.ts':
			/*!*************************************************************!*\
  !*** ./packages/nodalis-cli/sources/commands/commands.ts ***!
  \*************************************************************/
			/*! flagged exports */
			/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
			/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
			/*! other exports [not provided] [no usage info] */
			/*! runtime requirements: __webpack_exports__, __webpack_require__ */
			/***/ (__unused_webpack_module, exports, __webpack_require__) => {
				'use strict';
				eval(
					'\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst BuildCommand_1 = __webpack_require__(/*! ./BuildCommand */ "./packages/nodalis-cli/sources/commands/BuildCommand.ts");\nconst GenerateCommand_1 = __webpack_require__(/*! ./GenerateCommand */ "./packages/nodalis-cli/sources/commands/GenerateCommand.ts");\n// import { LintCommand } from \'./LintCommand\';\nconst StartCommand_1 = __webpack_require__(/*! ./StartCommand */ "./packages/nodalis-cli/sources/commands/StartCommand.ts");\nconst TestCommand_1 = __webpack_require__(/*! ./TestCommand */ "./packages/nodalis-cli/sources/commands/TestCommand.ts");\nconst WelcomeCommand_1 = __webpack_require__(/*! ./WelcomeCommand */ "./packages/nodalis-cli/sources/commands/WelcomeCommand.ts");\nconst commands = [\n    BuildCommand_1.BuildCommand,\n    GenerateCommand_1.GenerateCommand,\n    // LintCommand,\n    StartCommand_1.StartCommand,\n    TestCommand_1.TestCommand,\n    WelcomeCommand_1.WelcomeCommand,\n];\nexports.default = commands;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/commands/commands.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/index.ts':
			/*!*************************************************!*\
  !*** ./packages/nodalis-cli/sources/index.ts ***!
  \*************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// import { createPromptModule } from \'inquirer\';\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nconst commands_1 = __importDefault(__webpack_require__(/*! ./commands/commands */ "./packages/nodalis-cli/sources/commands/commands.ts"));\nvar BaseCommand_1 = __webpack_require__(/*! ./tools/BaseCommand */ "./packages/nodalis-cli/sources/tools/BaseCommand.ts");\nObject.defineProperty(exports, "BaseCommand", ({ enumerable: true, get: function () { return BaseCommand_1.BaseCommand; } }));\n/**\n * Recursively register commands in `commands/`\n * @param cli the Clipanion instance.\n */\nasync function registerCommands(cli) {\n    for (const command of commands_1.default) {\n        cli.register(command);\n    }\n}\n// const prompt = createPromptModule({\n//   input: this.context.stdin,\n//   output: this.context.stdout,\n// });\nasync function main() {\n    async function run() {\n        const cli = new clipanion_1.Cli({\n            binaryLabel: \'Nodalis\',\n            binaryName: \'nodalis\',\n            binaryVersion: \'0.1.0\',\n        });\n        registerCommands(cli);\n        try {\n            await exec(cli);\n        }\n        catch (error) {\n            process.stdout.write(cli.error(error));\n            process.exitCode = 1;\n        }\n    }\n    async function exec(cli) {\n        const command = cli.process(process.argv.slice(2));\n        cli.runExit(command, {\n            cwd: process.cwd(),\n            quiet: false,\n            stdin: process.stdin,\n            stdout: process.stdout,\n            stderr: process.stderr,\n        });\n    }\n    return run().catch((error) => {\n        process.stdout.write(error.stack || error.message);\n        process.exitCode = 1;\n    });\n}\nmain();\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/index.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-cli/sources/tools/BaseCommand.ts':
			/*!*************************************************************!*\
  !*** ./packages/nodalis-cli/sources/tools/BaseCommand.ts ***!
  \*************************************************************/
			/*! flagged exports */
			/*! export BaseCommand [provided] [no usage info] [missing usage info prevents renaming] */
			/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
			/*! other exports [not provided] [no usage info] */
			/*! runtime requirements: __webpack_exports__, __webpack_require__ */
			/***/ (__unused_webpack_module, exports, __webpack_require__) => {
				'use strict';
				eval(
					'\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BaseCommand = void 0;\nconst clipanion_1 = __webpack_require__(/*! clipanion */ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js");\nclass BaseCommand extends clipanion_1.Command {\n    stdout(chunk) {\n        this.context.stdout.write(chunk);\n    }\n    stderr(chunk) {\n        this.context.stderr.write(chunk);\n    }\n}\nexports.BaseCommand = BaseCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-cli/sources/tools/BaseCommand.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-core/sources/AbstractConfiguration.ts':
			/*!******************************************************************!*\
  !*** ./packages/nodalis-core/sources/AbstractConfiguration.ts ***!
  \******************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.AbstractConfiguration = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ "path"));\nclass AbstractConfiguration {\n    identity(value) {\n        return value;\n    }\n    findConfig(config) {\n        return config;\n    }\n    findProjectCwd(startingCwd) {\n        let projectCwd = null;\n        let nextCwd = startingCwd;\n        let currentCwd = null;\n        while (nextCwd !== currentCwd) {\n            currentCwd = nextCwd;\n            if (fs_1.default.existsSync(path_1.default.join(currentCwd, \'package.json\'))) {\n                console.log(`Found package!`);\n                projectCwd = currentCwd;\n            }\n            if (fs_1.default.existsSync(path_1.default.join(currentCwd, \'.nodalis.ts\'))) {\n                console.log(`Found config!`);\n                projectCwd = currentCwd;\n                break;\n            }\n            if (projectCwd !== null) {\n                break;\n            }\n            nextCwd = path_1.default.dirname(currentCwd);\n        }\n        return projectCwd;\n    }\n}\nexports.AbstractConfiguration = AbstractConfiguration;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-core/sources/AbstractConfiguration.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-core/sources/CommandContext.ts':
			/*!***********************************************************!*\
  !*** ./packages/nodalis-core/sources/CommandContext.ts ***!
  \***********************************************************/
			/*! flagged exports */
			/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
			/*! other exports [not provided] [no usage info] */
			/*! runtime requirements: __webpack_exports__ */
			/***/ (__unused_webpack_module, exports) => {
				'use strict';
				eval(
					'\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-core/sources/CommandContext.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-core/sources/NodalisConfig.ts':
			/*!************************************************************!*\
  !*** ./packages/nodalis-core/sources/NodalisConfig.ts ***!
  \************************************************************/
			/*! flagged exports */
			/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
			/*! other exports [not provided] [no usage info] */
			/*! runtime requirements: __webpack_exports__ */
			/***/ (__unused_webpack_module, exports) => {
				'use strict';
				eval(
					'\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-core/sources/NodalisConfig.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-core/sources/ProjectConfiguration.ts':
			/*!*****************************************************************!*\
  !*** ./packages/nodalis-core/sources/ProjectConfiguration.ts ***!
  \*****************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ProjectConfiguration = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));\nconst module_1 = __webpack_require__(/*! module */ "module");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ "path"));\nconst AbstractConfiguration_1 = __webpack_require__(/*! ./AbstractConfiguration */ "./packages/nodalis-core/sources/AbstractConfiguration.ts");\n// Dangerously setup our resolver\nconst requireAbs = (module_1.createRequire || module_1.createRequireFromPath)(path_1.default.resolve(__dirname, "./index.ts"));\nclass ProjectConfiguration extends AbstractConfiguration_1.AbstractConfiguration {\n    constructor(startingCwd) {\n        super();\n        this.cwd = startingCwd;\n    }\n    static async find() {\n        this.requireConfig();\n    }\n    static async requireConfig() {\n        const rootDir = await this.findProjectCwd(process.cwd(), true);\n        let reqConfig = requireAbs(`${rootDir}\\\\nodalis.json`);\n        if (reqConfig.default) {\n            reqConfig = reqConfig.default;\n        }\n        return reqConfig;\n    }\n    /**\n     * Returns an absolute path from within a specified workspace to a specified path.\n     * If using a root related path, use `resolveProjectRoot` instead.\n     * @param workspace the workspace, as defined in `<rootDir>/package.json`, to look for.\n     * @param desiredPath the path or file we\'re looking for.\n     * @param filename the optional file we\'re looking for.\n     */\n    static async resolveProjectWorkspace(workspace, desiredPath, filename) {\n        const ws = await this.workspace(workspace, true);\n        const resolvedPath = path_1.default.resolve(ws, filename ? `${desiredPath}/${filename}` : desiredPath);\n        try {\n            if (desiredPath == "lib") {\n                fs_1.default.access(resolvedPath, fs_1.default.constants.F_OK, (err) => {\n                    console.log(err);\n                    if (err) {\n                        fs_1.default.mkdirSync(resolvedPath);\n                        return resolvedPath;\n                    }\n                    else {\n                        fs_1.default.accessSync(resolvedPath, fs_1.default.constants.F_OK);\n                        return resolvedPath;\n                    }\n                });\n                return resolvedPath;\n            }\n            else {\n                fs_1.default.accessSync(resolvedPath, fs_1.default.constants.F_OK);\n                return resolvedPath;\n            }\n        }\n        catch (err) {\n            throw `Path "${resolvedPath}" does not exist!`;\n        }\n    }\n    /**\n     * Returns an absolute path from the `<rootDir>` to the desired path.\n     * If using a workspace related path, use `resolveProjectWorkspace` instead.\n     * @param desiredPath the path or root file we\'re looking for.\n     * @param filename the file we\'re looking for.\n     */\n    static async resolveProjectRoot(desiredPath, filename) {\n        const root = await this.findProjectCwd(process.cwd(), true);\n        const resolvedPath = path_1.default.resolve(root, filename ? `${desiredPath}/${filename}` : desiredPath);\n        // Make sure it exists\n        try {\n            fs_1.default.accessSync(resolvedPath, fs_1.default.constants.F_OK);\n            return resolvedPath;\n        }\n        catch (err) {\n            throw `Path "${resolvedPath}" does not exist!`;\n        }\n    }\n    /**\n     * Attempts tp find a workspace from the `workspaces` setting in the root\n     * `package.json` and return it\'s absolute path.\n     *\n     * - `pkg.workspaces` must exist\n     * - `pkg.main` must point to the workspace entry file\n     *   - i.e. `"main": "./sources/index.ts"`\n     */\n    static async workspace(workspaceName, returnWorkspacePath) {\n        const rootDir = await this.findProjectCwd(process.cwd(), true);\n        let currentCwd = process.cwd();\n        const data = fs_1.default.readFileSync(path_1.default.resolve(rootDir, "package.json"), {\n            encoding: "utf-8",\n        });\n        return new Promise(async (resolve, reject) => {\n            const parsedPkg = JSON.parse(data);\n            if (!parsedPkg.workspaces) {\n                throw new Error("package.json must include a workspaces setting.");\n            }\n            parsedPkg.workspaces.forEach((workspaceDir) => {\n                if (workspaceDir.includes("*")) {\n                    // Get the name of the workspaces folder i.e. "packages/*" => "packages"\n                    const workspace = workspaceDir.slice(0, -2);\n                    // Read each workspace\n                    fs_1.default.readdir(path_1.default.join(rootDir, workspace), async (err, files) => {\n                        if (err)\n                            throw console.log(`Error: ${err}. Files: ${files}`);\n                        for (let i = 0; i < files.length; i++) {\n                            const testDir = path_1.default.join(rootDir, workspace, files[i]);\n                            currentCwd = testDir;\n                            const workspacePkg = await JSON.parse(fs_1.default.readFileSync(`${currentCwd}/package.json`, {\n                                encoding: "utf-8",\n                            }));\n                            if (workspaceName == workspacePkg.name) {\n                                if (returnWorkspacePath)\n                                    resolve(path_1.default.resolve(currentCwd));\n                                else\n                                    resolve(path_1.default.resolve(currentCwd, workspacePkg.main));\n                            }\n                        }\n                        reject("Not a valid workspace!");\n                    });\n                }\n                else {\n                    // check against named workspaces\n                    resolve("");\n                }\n            });\n        });\n    }\n    /**\n     * Returns the root path or relative project path.\n     * @param startingCwd the directory to start with, safely pass `process.cwd()` when possible.\n     * @param nodalis search for the root directory.\n     */\n    static async findProjectCwd(startingCwd, nodalis = false) {\n        let projectCwd = "";\n        let nextCwd = startingCwd;\n        let currentCwd = "";\n        while (nextCwd !== currentCwd) {\n            currentCwd = nextCwd;\n            if (fs_1.default.existsSync(path_1.default.join(currentCwd, "package.json"))) {\n                projectCwd = currentCwd;\n            }\n            if (nodalis) {\n                if (fs_1.default.existsSync(path_1.default.join(currentCwd, "nodalis.json"))) {\n                    projectCwd = currentCwd;\n                    break;\n                }\n            }\n            else {\n                if (projectCwd !== "") {\n                    break;\n                }\n            }\n            nextCwd = path_1.default.dirname(currentCwd);\n        }\n        return projectCwd;\n    }\n}\nexports.ProjectConfiguration = ProjectConfiguration;\nasync function testResolveProjectWorkspace() {\n    const builder = await ProjectConfiguration.resolveProjectWorkspace("@nodalis/core", "lib");\n    console.log("BuilderLocation: " + builder);\n}\ntestResolveProjectWorkspace().catch((err) => {\n    console.error(err);\n});\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-core/sources/ProjectConfiguration.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-core/sources/env.ts':
			/*!************************************************!*\
  !*** ./packages/nodalis-core/sources/env.ts ***!
  \************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.identity = exports.notImpl = exports.env = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js"));\nexports.env = {\n    /** Are we running in `development`? */\n    isDevelopment: process.env.BUILD_ENV == \'development\',\n    /** Are we running in `production`? */\n    isProduction: process.env.BUILD_ENV == \'production\',\n};\nexports.notImpl = chalk_1.default `Not Yet Implemented. Expected by {cyan v1.0.0}`;\nexports.identity = (value) => value;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-core/sources/env.ts?'
				);

				/***/
			},

		/***/ './packages/nodalis-core/sources/index.ts':
			/*!**************************************************!*\
  !*** ./packages/nodalis-core/sources/index.ts ***!
  \**************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
			/***/ function (__unused_webpack_module, exports, __webpack_require__) {
				'use strict';
				eval(
					'\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./NodalisConfig */ "./packages/nodalis-core/sources/NodalisConfig.ts"), exports);\n__exportStar(__webpack_require__(/*! ./env */ "./packages/nodalis-core/sources/env.ts"), exports);\n__exportStar(__webpack_require__(/*! ./ProjectConfiguration */ "./packages/nodalis-core/sources/ProjectConfiguration.ts"), exports);\n__exportStar(__webpack_require__(/*! ./CommandContext */ "./packages/nodalis-core/sources/CommandContext.ts"), exports);\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./packages/nodalis-core/sources/index.ts?'
				);

				/***/
			},

		/***/ './.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js':
			/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js ***!
  \*******************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module.loaded, module.id, module, __webpack_require__.nmd, __webpack_require__, __webpack_require__.* */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					"/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst wrapAnsi16 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => (...args) => {\n\tconst rgb = fn(...args);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nconst ansi2ansi = n => n;\nconst rgb2rgb = (r, g, b) => [r, g, b];\n\nconst setLazyProperty = (object, property, get) => {\n\tObject.defineProperty(object, property, {\n\t\tget: () => {\n\t\t\tconst value = get();\n\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\treturn value;\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n};\n\n/** @type {typeof import('color-convert')} */\nlet colorConvert;\nconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\tif (colorConvert === undefined) {\n\t\tcolorConvert = __webpack_require__(/*! color-convert */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js\");\n\t}\n\n\tconst offset = isBackground ? 10 : 0;\n\tconst styles = {};\n\n\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\tif (sourceSpace === targetSpace) {\n\t\t\tstyles[name] = wrap(identity, offset);\n\t\t} else if (typeof suite === 'object') {\n\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t}\n\t}\n\n\treturn styles;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js':
			/*!**************************************************************************************************!*\
  !*** ./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js ***!
  \**************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					"\nconst ansiStyles = __webpack_require__(/*! ansi-styles */ \"./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js\");\nconst {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(/*! supports-color */ \"./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js\");\nconst {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n} = __webpack_require__(/*! ./util */ \"./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js\");\n\nconst {isArray} = Array;\n\n// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m'\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nclass ChalkClass {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = {};\n\tapplyOptions(chalk, options);\n\n\tchalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);\n\n\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\tObject.setPrototypeOf(chalk.template, chalk);\n\n\tchalk.template.constructor = () => {\n\t\tthrow new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');\n\t};\n\n\tchalk.template.Instance = ChalkClass;\n\n\treturn chalk.template;\n};\n\nfunction Chalk(options) {\n\treturn chalkFactory(options);\n}\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this._styler, true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t}\n};\n\nconst usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nfor (const model of usedModels) {\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this._generator.level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis._generator.level = level;\n\t\t}\n\t}\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\tconst builder = (...arguments_) => {\n\t\tif (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n\t\t\t// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n\t\t\treturn applyStyle(builder, chalkTag(builder, ...arguments_));\n\t\t}\n\n\t\t// Single argument is hot path, implicit coercion is faster than anything\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\treturn applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\t};\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder._generator = self;\n\tbuilder._styler = _styler;\n\tbuilder._isEmpty = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self._isEmpty ? '' : string;\n\t}\n\n\tlet styler = self._styler;\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.indexOf('\\u001B') !== -1) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nlet template;\nconst chalkTag = (chalk, ...strings) => {\n\tconst [firstString] = strings;\n\n\tif (!isArray(firstString) || !isArray(firstString.raw)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn strings.join(' ');\n\t}\n\n\tconst arguments_ = strings.slice(1);\n\tconst parts = [firstString.raw[0]];\n\n\tfor (let i = 1; i < firstString.length; i++) {\n\t\tparts.push(\n\t\t\tString(arguments_[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'),\n\t\t\tString(firstString.raw[i])\n\t\t);\n\t}\n\n\tif (template === undefined) {\n\t\ttemplate = __webpack_require__(/*! ./templates */ \"./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js\");\n\t}\n\n\treturn template(chalk, parts.join(''));\n};\n\nObject.defineProperties(Chalk.prototype, styles);\n\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\n\nmodule.exports = chalk;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js':
			/*!******************************************************************************************************!*\
  !*** ./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js ***!
  \******************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					"\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tconst u = c[0] === 'u';\n\tconst bracket = c[1] === '{';\n\n\tif ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\tif (u && bracket) {\n\t\treturn String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, arguments_) {\n\tconst results = [];\n\tconst chunks = arguments_.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tconst number = Number(chunk);\n\t\tif (!Number.isNaN(number)) {\n\t\t\tresults.push(number);\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const [styleName, styles] of Object.entries(enabled)) {\n\t\tif (!Array.isArray(styles)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(styleName in current)) {\n\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t}\n\n\t\tcurrent = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, temporary) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttemporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n\t\tif (escapeCharacter) {\n\t\t\tchunk.push(unescape(escapeCharacter));\n\t\t} else if (style) {\n\t\t\tconst string = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(character);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMessage);\n\t}\n\n\treturn chunks.join('');\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js':
			/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js ***!
  \*************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					"\n\nconst stringReplaceAll = (string, substring, replacer) => {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nmodule.exports = {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js':
			/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js ***!
  \*******************************************************************************************************/
			/*! flagged exports */
			/*! export Cli [provided] [no usage info] [missing usage info prevents renaming] */
			/*! export Command [provided] [no usage info] [missing usage info prevents renaming] */
			/*! export UsageError [provided] [no usage info] [missing usage info prevents renaming] */
			/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
			/*! other exports [not provided] [no usage info] */
			/*! runtime requirements: __webpack_exports__ */
			/***/ (__unused_webpack_module, exports) => {
				'use strict';
				eval(
					'\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nclass Command {\n    constructor() {\n        /**\n         * Predefined that will be set to true if `-h,--help` has been used, in which case `Command#execute` shouldn\'t be called.\n         */\n        this.help = false;\n    }\n    static getMeta(prototype) {\n        const base = prototype.constructor;\n        return base.meta = Object.prototype.hasOwnProperty.call(base, `meta`) ? base.meta : {\n            definitions: [],\n            transformers: [\n                (state, command) => {\n                    for (const { name, value } of state.options) {\n                        if (name === `-h` || name === `--help`) {\n                            // @ts-ignore: The property is meant to have been defined by the child class\n                            command.help = value;\n                        }\n                    }\n                },\n            ],\n        };\n    }\n    static resolveMeta(prototype) {\n        const definitions = [];\n        const transformers = [];\n        for (let proto = prototype; proto instanceof Command; proto = proto.__proto__) {\n            const meta = this.getMeta(proto);\n            for (const definition of meta.definitions)\n                definitions.push(definition);\n            for (const transformer of meta.transformers) {\n                transformers.push(transformer);\n            }\n        }\n        return {\n            definitions,\n            transformers,\n        };\n    }\n    static registerDefinition(prototype, definition) {\n        this.getMeta(prototype).definitions.push(definition);\n    }\n    static registerTransformer(prototype, transformer) {\n        this.getMeta(prototype).transformers.push(transformer);\n    }\n    static addPath(...path) {\n        this.Path(...path)(this.prototype, `execute`);\n    }\n    static addOption(name, builder) {\n        builder(this.prototype, name);\n    }\n    /**\n     * Wrap the specified command to be attached to the given path on the command line.\n     * The first path thus attached will be considered the "main" one, and all others will be aliases.\n     * @param path The command path.\n     */\n    static Path(...path) {\n        return (prototype, propertyName) => {\n            this.registerDefinition(prototype, command => {\n                command.addPath(path);\n            });\n        };\n    }\n    /**\n     * Register a boolean listener for the given option names. When Clipanion detects that this argument is present, the value will be set to false. The value won\'t be set unless the option is found, so you must remember to set it to an appropriate default value.\n     * @param descriptor the option names.\n     */\n    static Boolean(descriptor, { hidden = false } = {}) {\n        return (prototype, propertyName) => {\n            const optNames = descriptor.split(`,`);\n            this.registerDefinition(prototype, command => {\n                command.addOption({ names: optNames, arity: 0, hidden, allowBinding: false });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                for (const { name, value } of state.options) {\n                    if (optNames.includes(name)) {\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName] = value;\n                    }\n                }\n            });\n        };\n    }\n    static String(descriptor = { required: true }, { tolerateBoolean = false, hidden = false } = {}) {\n        return (prototype, propertyName) => {\n            if (typeof descriptor === `string`) {\n                const optNames = descriptor.split(`,`);\n                this.registerDefinition(prototype, command => {\n                    // If tolerateBoolean is specified, the command will only accept a string value\n                    // using the bind syntax and will otherwise act like a boolean option\n                    command.addOption({ names: optNames, arity: tolerateBoolean ? 0 : 1, hidden });\n                });\n                this.registerTransformer(prototype, (state, command) => {\n                    for (const { name, value } of state.options) {\n                        if (optNames.includes(name)) {\n                            // @ts-ignore: The property is meant to have been defined by the child class\n                            command[propertyName] = value;\n                        }\n                    }\n                });\n            }\n            else {\n                this.registerDefinition(prototype, command => {\n                    command.addPositional({ name: propertyName, required: descriptor.required });\n                });\n                this.registerTransformer(prototype, (state, command) => {\n                    if (state.positionals.length > 0) {\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName] = state.positionals.shift().value;\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be pushed into the array represented in the property.\n     */\n    static Array(descriptor, { hidden = false } = {}) {\n        return (prototype, propertyName) => {\n            const optNames = descriptor.split(`,`);\n            this.registerDefinition(prototype, command => {\n                command.addOption({ names: optNames, arity: 1, hidden });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                for (const { name, value } of state.options) {\n                    if (optNames.includes(name)) {\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName] = command[propertyName] || [];\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName].push(value);\n                    }\n                }\n            });\n        };\n    }\n    static Rest({ required = 0 } = {}) {\n        return (prototype, propertyName) => {\n            this.registerDefinition(prototype, command => {\n                command.addRest({ name: propertyName, required });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                // @ts-ignore: The property is meant to have been defined by the child class\n                command[propertyName] = state.positionals.map(({ value }) => value);\n            });\n        };\n    }\n    /**\n     * Register a listener that takes all the arguments remaining (including options and such) and store them into the selected property.\n     * Note that all methods affecting positional arguments are evaluated in the definition order; don\'t mess with it (for example sorting your properties in ascendent order might have adverse results).\n     */\n    static Proxy({ required = 0 } = {}) {\n        return (prototype, propertyName) => {\n            this.registerDefinition(prototype, command => {\n                command.addProxy({ required });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                // @ts-ignore: The property is meant to have been defined by the child class\n                command[propertyName] = state.positionals.map(({ value }) => value);\n            });\n        };\n    }\n    /**\n     * Defines the usage information for the given command.\n     * @param usage\n     */\n    static Usage(usage) {\n        return usage;\n    }\n    /**\n     * Defines the schema for the given command.\n     * @param schema\n     */\n    static Schema(schema) {\n        return schema;\n    }\n    async validateAndExecute() {\n        const commandClass = this.constructor;\n        const schema = commandClass.schema;\n        if (typeof schema !== `undefined`) {\n            try {\n                await schema.validate(this);\n            }\n            catch (error) {\n                if (error.name === `ValidationError`)\n                    error.clipanion = { type: `usage` };\n                throw error;\n            }\n        }\n        const exitCode = await this.execute();\n        if (typeof exitCode !== `undefined`) {\n            return exitCode;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n/**\n * A list of useful semi-opinionated command entries that have to be registered manually.\n *\n * They cover the basic needs of most CLIs (e.g. help command, version command).\n *\n * @example\n * cli.register(Command.Entries.Help);\n * cli.register(Command.Entries.Version);\n */\nCommand.Entries = {};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\n\nclass HelpCommand extends Command {\n    async execute() {\n        this.context.stdout.write(this.cli.usage(null));\n    }\n}\n__decorate([\n    Command.Path(`--help`),\n    Command.Path(`-h`)\n], HelpCommand.prototype, "execute", null);\n\nclass VersionCommand extends Command {\n    async execute() {\n        var _a;\n        this.context.stdout.write(`${(_a = this.cli.binaryVersion) !== null && _a !== void 0 ? _a : `<unknown>`}\\n`);\n    }\n}\n__decorate([\n    Command.Path(`--version`),\n    Command.Path(`-v`)\n], VersionCommand.prototype, "execute", null);\n\nconst NODE_INITIAL = 0;\nconst NODE_SUCCESS = 1;\nconst NODE_ERRORED = 2;\nconst START_OF_INPUT = `\\u0001`;\nconst END_OF_INPUT = `\\u0000`;\nconst HELP_COMMAND_INDEX = -1;\nconst HELP_REGEX = /^(-h|--help)(?:=([0-9]+))?$/;\nconst OPTION_REGEX = /^(--[a-z]+(?:-[a-z]+)*|-[a-zA-Z]+)$/;\nconst BATCH_REGEX = /^-[a-zA-Z]{2,}$/;\nconst BINDING_REGEX = /^([^=]+)=([\\s\\S]*)$/;\nconst DEBUG = process.env.DEBUG_CLI === `1`;\n\n/**\n * A generic usage error with the name `UsageError`.\n *\n * It should be used over `Error` only when it\'s the user\'s fault.\n */\nclass UsageError extends Error {\n    constructor(message) {\n        super(message);\n        this.clipanion = { type: `usage` };\n        this.name = `UsageError`;\n    }\n}\nclass UnknownSyntaxError extends Error {\n    constructor(input, candidates) {\n        super();\n        this.input = input;\n        this.candidates = candidates;\n        this.clipanion = { type: `none` };\n        this.name = `UnknownSyntaxError`;\n        if (this.candidates.length === 0) {\n            this.message = `Command not found, but we\'re not sure what\'s the alternative.`;\n        }\n        else if (this.candidates.length === 1 && this.candidates[0].reason !== null) {\n            const [{ usage, reason }] = this.candidates;\n            this.message = `${reason}\\n\\n$ ${usage}`;\n        }\n        else if (this.candidates.length === 1) {\n            const [{ usage }] = this.candidates;\n            this.message = `Command not found; did you mean:\\n\\n$ ${usage}\\n${whileRunning(input)}`;\n        }\n        else {\n            this.message = `Command not found; did you mean one of:\\n\\n${this.candidates.map(({ usage }, index) => {\n                return `${`${index}.`.padStart(4)} ${usage}`;\n            }).join(`\\n`)}\\n\\n${whileRunning(input)}`;\n        }\n    }\n}\nclass AmbiguousSyntaxError extends Error {\n    constructor(input, usages) {\n        super();\n        this.input = input;\n        this.usages = usages;\n        this.clipanion = { type: `none` };\n        this.name = `AmbiguousSyntaxError`;\n        this.message = `Cannot find who to pick amongst the following alternatives:\\n\\n${this.usages.map((usage, index) => {\n            return `${`${index}.`.padStart(4)} ${usage}`;\n        }).join(`\\n`)}\\n\\n${whileRunning(input)}`;\n    }\n}\nconst whileRunning = (input) => `While running ${input.filter(token => {\n    return token !== END_OF_INPUT;\n}).map(token => {\n    const json = JSON.stringify(token);\n    if (token.match(/\\s/) || token.length === 0 || json !== `"${token}"`) {\n        return json;\n    }\n    else {\n        return token;\n    }\n}).join(` `)}`;\n\n// ------------------------------------------------------------------------\nfunction debug(str) {\n    if (DEBUG) {\n        console.log(str);\n    }\n}\nfunction makeStateMachine() {\n    return {\n        nodes: [makeNode(), makeNode(), makeNode()],\n    };\n}\nfunction makeAnyOfMachine(inputs) {\n    const output = makeStateMachine();\n    const heads = [];\n    let offset = output.nodes.length;\n    for (const input of inputs) {\n        heads.push(offset);\n        for (let t = 0; t < input.nodes.length; ++t)\n            if (!isTerminalNode(t))\n                output.nodes.push(cloneNode(input.nodes[t], offset));\n        offset += input.nodes.length - 2;\n    }\n    for (const head of heads)\n        registerShortcut(output, NODE_INITIAL, head);\n    return output;\n}\nfunction injectNode(machine, node) {\n    machine.nodes.push(node);\n    return machine.nodes.length - 1;\n}\nfunction simplifyMachine(input) {\n    const visited = new Set();\n    const process = (node) => {\n        if (visited.has(node))\n            return;\n        visited.add(node);\n        const nodeDef = input.nodes[node];\n        for (const transitions of Object.values(nodeDef.statics))\n            for (const { to } of transitions)\n                process(to);\n        for (const [, { to }] of nodeDef.dynamics)\n            process(to);\n        for (const { to } of nodeDef.shortcuts)\n            process(to);\n        const shortcuts = new Set(nodeDef.shortcuts.map(({ to }) => to));\n        while (nodeDef.shortcuts.length > 0) {\n            const { to } = nodeDef.shortcuts.shift();\n            const toDef = input.nodes[to];\n            for (const [segment, transitions] of Object.entries(toDef.statics)) {\n                let store = !Object.prototype.hasOwnProperty.call(nodeDef.statics, segment)\n                    ? nodeDef.statics[segment] = []\n                    : nodeDef.statics[segment];\n                for (const transition of transitions) {\n                    if (!store.some(({ to }) => transition.to === to)) {\n                        store.push(transition);\n                    }\n                }\n            }\n            for (const [test, transition] of toDef.dynamics)\n                if (!nodeDef.dynamics.some(([otherTest, { to }]) => test === otherTest && transition.to === to))\n                    nodeDef.dynamics.push([test, transition]);\n            for (const transition of toDef.shortcuts) {\n                if (!shortcuts.has(transition.to)) {\n                    nodeDef.shortcuts.push(transition);\n                    shortcuts.add(transition.to);\n                }\n            }\n        }\n    };\n    process(NODE_INITIAL);\n}\nfunction debugMachine(machine, { prefix = `` } = {}) {\n    debug(`${prefix}Nodes are:`);\n    for (let t = 0; t < machine.nodes.length; ++t) {\n        debug(`${prefix}  ${t}: ${JSON.stringify(machine.nodes[t])}`);\n    }\n}\nfunction runMachineInternal(machine, input, partial = false) {\n    debug(`Running a vm on ${JSON.stringify(input)}`);\n    let branches = [{ node: NODE_INITIAL, state: {\n                candidateUsage: null,\n                errorMessage: null,\n                ignoreOptions: false,\n                options: [],\n                path: [],\n                positionals: [],\n                remainder: null,\n                selectedIndex: null,\n            } }];\n    debugMachine(machine, { prefix: `  ` });\n    const tokens = [START_OF_INPUT, ...input];\n    for (let t = 0; t < tokens.length; ++t) {\n        const segment = tokens[t];\n        debug(`  Processing ${JSON.stringify(segment)}`);\n        const nextBranches = [];\n        for (const { node, state } of branches) {\n            debug(`    Current node is ${node}`);\n            const nodeDef = machine.nodes[node];\n            if (node === NODE_ERRORED) {\n                nextBranches.push({ node, state });\n                continue;\n            }\n            console.assert(nodeDef.shortcuts.length === 0, `Shortcuts should have been eliminated by now`);\n            const hasExactMatch = Object.prototype.hasOwnProperty.call(nodeDef.statics, segment);\n            if (!partial || t < tokens.length - 1 || hasExactMatch) {\n                if (hasExactMatch) {\n                    const transitions = nodeDef.statics[segment];\n                    for (const { to, reducer } of transitions) {\n                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });\n                        debug(`      Static transition to ${to} found`);\n                    }\n                }\n                else {\n                    debug(`      No static transition found`);\n                }\n            }\n            else {\n                let hasMatches = false;\n                for (const candidate of Object.keys(nodeDef.statics)) {\n                    if (!candidate.startsWith(segment))\n                        continue;\n                    if (segment === candidate) {\n                        for (const { to, reducer } of nodeDef.statics[candidate]) {\n                            nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });\n                            debug(`      Static transition to ${to} found`);\n                        }\n                    }\n                    else {\n                        for (const { to, reducer } of nodeDef.statics[candidate]) {\n                            nextBranches.push({ node: to, state: Object.assign(Object.assign({}, state), { remainder: candidate.slice(segment.length) }) });\n                            debug(`      Static transition to ${to} found (partial match)`);\n                        }\n                    }\n                    hasMatches = true;\n                }\n                if (!hasMatches) {\n                    debug(`      No partial static transition found`);\n                }\n            }\n            if (segment !== END_OF_INPUT) {\n                for (const [test, { to, reducer }] of nodeDef.dynamics) {\n                    if (execute(tests, test, state, segment)) {\n                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });\n                        debug(`      Dynamic transition to ${to} found (via ${test})`);\n                    }\n                }\n            }\n        }\n        if (nextBranches.length === 0) {\n            throw new UnknownSyntaxError(input, branches.filter(({ node }) => {\n                return node !== NODE_ERRORED;\n            }).map(({ state }) => {\n                return { usage: state.candidateUsage, reason: null };\n            }));\n        }\n        if (nextBranches.every(({ node }) => node === NODE_ERRORED)) {\n            throw new UnknownSyntaxError(input, nextBranches.map(({ state }) => {\n                return { usage: state.candidateUsage, reason: state.errorMessage };\n            }));\n        }\n        branches = trimSmallerBranches(nextBranches);\n    }\n    if (branches.length > 0) {\n        debug(`  Results:`);\n        for (const branch of branches) {\n            debug(`    - ${branch.node} -> ${JSON.stringify(branch.state)}`);\n        }\n    }\n    else {\n        debug(`  No results`);\n    }\n    return branches;\n}\nfunction checkIfNodeIsFinished(node, state) {\n    if (state.selectedIndex !== null)\n        return true;\n    if (Object.prototype.hasOwnProperty.call(node.statics, END_OF_INPUT))\n        for (const { to } of node.statics[END_OF_INPUT])\n            if (to === NODE_SUCCESS)\n                return true;\n    return false;\n}\nfunction suggestMachine(machine, input, partial) {\n    // If we\'re accepting partial matches, then exact matches need to be\n    // prefixed with an extra space.\n    const prefix = partial && input.length > 0 ? [``] : [];\n    const branches = runMachineInternal(machine, input, partial);\n    const suggestions = [];\n    const suggestionsJson = new Set();\n    const traverseSuggestion = (suggestion, node, skipFirst = true) => {\n        let nextNodes = [node];\n        while (nextNodes.length > 0) {\n            const currentNodes = nextNodes;\n            nextNodes = [];\n            for (const node of currentNodes) {\n                const nodeDef = machine.nodes[node];\n                const keys = Object.keys(nodeDef.statics);\n                for (const key of Object.keys(nodeDef.statics)) {\n                    const segment = keys[0];\n                    for (const { to, reducer } of nodeDef.statics[segment]) {\n                        if (reducer !== `pushPath`)\n                            continue;\n                        if (!skipFirst)\n                            suggestion.push(segment);\n                        nextNodes.push(to);\n                    }\n                }\n            }\n            skipFirst = false;\n        }\n        const json = JSON.stringify(suggestion);\n        if (suggestionsJson.has(json))\n            return;\n        suggestions.push(suggestion);\n        suggestionsJson.add(json);\n    };\n    for (const { node, state } of branches) {\n        if (state.remainder !== null) {\n            traverseSuggestion([state.remainder], node);\n            continue;\n        }\n        const nodeDef = machine.nodes[node];\n        const isFinished = checkIfNodeIsFinished(nodeDef, state);\n        for (const [candidate, transitions] of Object.entries(nodeDef.statics))\n            if ((isFinished && candidate !== END_OF_INPUT) || (!candidate.startsWith(`-`) && transitions.some(({ reducer }) => reducer === `pushPath`)))\n                traverseSuggestion([...prefix, candidate], node);\n        if (!isFinished)\n            continue;\n        for (const [test, { to }] of nodeDef.dynamics) {\n            if (to === NODE_ERRORED)\n                continue;\n            const tokens = suggest(test, state);\n            if (tokens === null)\n                continue;\n            for (const token of tokens) {\n                traverseSuggestion([...prefix, token], node);\n            }\n        }\n    }\n    return [...suggestions].sort();\n}\nfunction runMachine(machine, input) {\n    const branches = runMachineInternal(machine, [...input, END_OF_INPUT]);\n    return selectBestState(input, branches.map(({ state }) => {\n        return state;\n    }));\n}\nfunction trimSmallerBranches(branches) {\n    let maxPathSize = 0;\n    for (const { state } of branches)\n        if (state.path.length > maxPathSize)\n            maxPathSize = state.path.length;\n    return branches.filter(({ state }) => {\n        return state.path.length === maxPathSize;\n    });\n}\nfunction selectBestState(input, states) {\n    const terminalStates = states.filter(state => {\n        return state.selectedIndex !== null;\n    });\n    if (terminalStates.length === 0)\n        throw new Error();\n    let maxPathSize = 0;\n    for (const state of terminalStates)\n        if (state.path.length > maxPathSize)\n            maxPathSize = state.path.length;\n    const bestPathBranches = terminalStates.filter(state => {\n        return state.path.length === maxPathSize;\n    });\n    const getPositionalCount = (state) => state.positionals.filter(({ extra }) => {\n        return !extra;\n    }).length + state.options.length;\n    const statesWithPositionalCount = bestPathBranches.map(state => {\n        return { state, positionalCount: getPositionalCount(state) };\n    });\n    let maxPositionalCount = 0;\n    for (const { positionalCount } of statesWithPositionalCount)\n        if (positionalCount > maxPositionalCount)\n            maxPositionalCount = positionalCount;\n    const bestPositionalStates = statesWithPositionalCount.filter(({ positionalCount }) => {\n        return positionalCount === maxPositionalCount;\n    }).map(({ state }) => {\n        return state;\n    });\n    const fixedStates = aggregateHelpStates(bestPositionalStates);\n    if (fixedStates.length > 1)\n        throw new AmbiguousSyntaxError(input, fixedStates.map(state => state.candidateUsage));\n    return fixedStates[0];\n}\nfunction aggregateHelpStates(states) {\n    const notHelps = [];\n    const helps = [];\n    for (const state of states) {\n        if (state.selectedIndex === HELP_COMMAND_INDEX) {\n            helps.push(...state.options);\n        }\n        else {\n            notHelps.push(state);\n        }\n    }\n    if (helps.length > 0) {\n        notHelps.push({\n            candidateUsage: null,\n            errorMessage: null,\n            ignoreOptions: false,\n            path: [],\n            positionals: [],\n            options: helps,\n            remainder: null,\n            selectedIndex: HELP_COMMAND_INDEX,\n        });\n    }\n    return notHelps;\n}\nfunction makeNode() {\n    return {\n        dynamics: [],\n        shortcuts: [],\n        statics: {},\n    };\n}\nfunction isTerminalNode(node) {\n    return node === NODE_SUCCESS || node === NODE_ERRORED;\n}\nfunction cloneTransition(input, offset = 0) {\n    return {\n        to: !isTerminalNode(input.to) ? input.to > 2 ? input.to + offset - 2 : input.to + offset : input.to,\n        reducer: input.reducer,\n    };\n}\nfunction cloneNode(input, offset = 0) {\n    const output = makeNode();\n    for (const [test, transition] of input.dynamics)\n        output.dynamics.push([test, cloneTransition(transition, offset)]);\n    for (const transition of input.shortcuts)\n        output.shortcuts.push(cloneTransition(transition, offset));\n    for (const [segment, transitions] of Object.entries(input.statics))\n        output.statics[segment] = transitions.map(transition => cloneTransition(transition, offset));\n    return output;\n}\nfunction registerDynamic(machine, from, test, to, reducer) {\n    machine.nodes[from].dynamics.push([test, { to, reducer }]);\n}\nfunction registerShortcut(machine, from, to, reducer) {\n    machine.nodes[from].shortcuts.push({ to, reducer });\n}\nfunction registerStatic(machine, from, test, to, reducer) {\n    let store = !Object.prototype.hasOwnProperty.call(machine.nodes[from].statics, test)\n        ? machine.nodes[from].statics[test] = []\n        : machine.nodes[from].statics[test];\n    store.push({ to, reducer });\n}\nfunction execute(store, callback, state, segment) {\n    if (Array.isArray(callback)) {\n        const [name, ...args] = callback;\n        return store[name](state, segment, ...args);\n    }\n    else {\n        return store[callback](state, segment);\n    }\n}\nfunction suggest(callback, state) {\n    const fn = Array.isArray(callback)\n        ? tests[callback[0]]\n        : tests[callback];\n    // @ts-ignore\n    if (typeof fn.suggest === `undefined`)\n        return null;\n    const args = Array.isArray(callback)\n        ? callback.slice(1)\n        : [];\n    // @ts-ignore\n    return fn.suggest(state, ...args);\n}\nconst tests = {\n    always: () => {\n        return true;\n    },\n    isNotOptionLike: (state, segment) => {\n        return state.ignoreOptions || !segment.startsWith(`-`);\n    },\n    isOption: (state, segment, name, hidden) => {\n        return !state.ignoreOptions && segment === name;\n    },\n    isBatchOption: (state, segment, names) => {\n        return !state.ignoreOptions && BATCH_REGEX.test(segment) && [...segment.slice(1)].every(name => names.includes(`-${name}`));\n    },\n    isBoundOption: (state, segment, names, options) => {\n        const optionParsing = segment.match(BINDING_REGEX);\n        return !state.ignoreOptions && !!optionParsing && OPTION_REGEX.test(optionParsing[1]) && names.includes(optionParsing[1])\n            // Disallow bound options with no arguments (i.e. booleans)\n            && options.filter(opt => opt.names.includes(optionParsing[1])).every(opt => opt.allowBinding);\n    },\n    isNegatedOption: (state, segment, name) => {\n        return !state.ignoreOptions && segment === `--no-${name.slice(2)}`;\n    },\n    isHelp: (state, segment) => {\n        return !state.ignoreOptions && HELP_REGEX.test(segment);\n    },\n    isUnsupportedOption: (state, segment, names) => {\n        return !state.ignoreOptions && segment.startsWith(`-`) && OPTION_REGEX.test(segment) && !names.includes(segment);\n    },\n    isInvalidOption: (state, segment) => {\n        return !state.ignoreOptions && segment.startsWith(`-`) && !OPTION_REGEX.test(segment);\n    },\n};\n// @ts-ignore\ntests.isOption.suggest = (state, name, hidden = true) => {\n    return !hidden ? [name] : null;\n};\nconst reducers = {\n    setCandidateUsage: (state, segment, usage) => {\n        return Object.assign(Object.assign({}, state), { candidateUsage: usage });\n    },\n    setSelectedIndex: (state, segment, index) => {\n        return Object.assign(Object.assign({}, state), { selectedIndex: index });\n    },\n    pushBatch: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat([...segment.slice(1)].map(name => ({ name: `-${name}`, value: true }))) });\n    },\n    pushBound: (state, segment) => {\n        const [, name, value] = segment.match(BINDING_REGEX);\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value }) });\n    },\n    pushPath: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { path: state.path.concat(segment) });\n    },\n    pushPositional: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: false }) });\n    },\n    pushExtra: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: true }) });\n    },\n    pushTrue: (state, segment, name = segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: true }) });\n    },\n    pushFalse: (state, segment, name = segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value: false }) });\n    },\n    pushUndefined: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: undefined }) });\n    },\n    setStringValue: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.slice(0, -1).concat(Object.assign(Object.assign({}, state.options[state.options.length - 1]), { value: segment })) });\n    },\n    inhibateOptions: (state) => {\n        return Object.assign(Object.assign({}, state), { ignoreOptions: true });\n    },\n    useHelp: (state, segment, command) => {\n        const [, name, index] = segment.match(HELP_REGEX);\n        if (typeof index !== `undefined`) {\n            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }, { name: `-i`, value: index }] });\n        }\n        else {\n            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }] });\n        }\n    },\n    setError: (state, segment, errorMessage) => {\n        if (segment === END_OF_INPUT) {\n            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage}.` });\n        }\n        else {\n            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage} ("${segment}").` });\n        }\n    },\n};\n// ------------------------------------------------------------------------\nconst NoLimits = Symbol();\nclass CommandBuilder {\n    constructor(cliIndex, cliOpts) {\n        this.allOptionNames = [];\n        this.arity = { leading: [], trailing: [], extra: [], proxy: false };\n        this.options = [];\n        this.paths = [];\n        this.cliIndex = cliIndex;\n        this.cliOpts = cliOpts;\n    }\n    addPath(path) {\n        this.paths.push(path);\n    }\n    setArity({ leading = this.arity.leading, trailing = this.arity.trailing, extra = this.arity.extra, proxy = this.arity.proxy }) {\n        Object.assign(this.arity, { leading, trailing, extra, proxy });\n    }\n    addPositional({ name = \'arg\', required = true } = {}) {\n        if (!required && this.arity.extra === NoLimits)\n            throw new Error(`Optional parameters cannot be declared when using .rest() or .proxy()`);\n        if (!required && this.arity.trailing.length > 0)\n            throw new Error(`Optional parameters cannot be declared after the required trailing positional arguments`);\n        if (!required && this.arity.extra !== NoLimits) {\n            this.arity.extra.push(name);\n        }\n        else if (this.arity.extra !== NoLimits && this.arity.extra.length === 0) {\n            this.arity.leading.push(name);\n        }\n        else {\n            this.arity.trailing.push(name);\n        }\n    }\n    addRest({ name = \'arg\', required = 0 } = {}) {\n        if (this.arity.extra === NoLimits)\n            throw new Error(`Infinite lists cannot be declared multiple times in the same command`);\n        if (this.arity.trailing.length > 0)\n            throw new Error(`Infinite lists cannot be declared after the required trailing positional arguments`);\n        for (let t = 0; t < required; ++t)\n            this.addPositional({ name });\n        this.arity.extra = NoLimits;\n    }\n    addProxy({ required = 0 } = {}) {\n        this.addRest({ required });\n        this.arity.proxy = true;\n    }\n    addOption({ names, arity = 0, hidden = false, allowBinding = true }) {\n        this.allOptionNames.push(...names);\n        this.options.push({ names, arity, hidden, allowBinding });\n    }\n    setContext(context) {\n        this.context = context;\n    }\n    usage({ detailed = true } = {}) {\n        const segments = [this.cliOpts.binaryName];\n        if (this.paths.length > 0)\n            segments.push(...this.paths[0]);\n        if (detailed) {\n            for (const { names, arity, hidden } of this.options) {\n                if (hidden)\n                    continue;\n                const args = [];\n                for (let t = 0; t < arity; ++t)\n                    args.push(` #${t}`);\n                segments.push(`[${names.join(`,`)}${args.join(``)}]`);\n            }\n            segments.push(...this.arity.leading.map(name => `<${name}>`));\n            if (this.arity.extra === NoLimits)\n                segments.push(`...`);\n            else\n                segments.push(...this.arity.extra.map(name => `[${name}]`));\n            segments.push(...this.arity.trailing.map(name => `<${name}>`));\n        }\n        return segments.join(` `);\n    }\n    compile() {\n        if (typeof this.context === `undefined`)\n            throw new Error(`Assertion failed: No context attached`);\n        const machine = makeStateMachine();\n        let firstNode = NODE_INITIAL;\n        firstNode = injectNode(machine, makeNode());\n        registerStatic(machine, NODE_INITIAL, START_OF_INPUT, firstNode, [`setCandidateUsage`, this.usage()]);\n        const positionalArgument = this.arity.proxy\n            ? `always`\n            : `isNotOptionLike`;\n        const paths = this.paths.length > 0\n            ? this.paths\n            : [[]];\n        for (const path of paths) {\n            let lastPathNode = firstNode;\n            // We allow options to be specified before the path. Note that we\n            // only do this when there is a path, otherwise there would be\n            // some redundancy with the options attached later.\n            if (path.length > 0) {\n                const optionPathNode = injectNode(machine, makeNode());\n                registerShortcut(machine, lastPathNode, optionPathNode);\n                this.registerOptions(machine, optionPathNode);\n                lastPathNode = optionPathNode;\n            }\n            for (let t = 0; t < path.length; ++t) {\n                const nextPathNode = injectNode(machine, makeNode());\n                registerStatic(machine, lastPathNode, path[t], nextPathNode, `pushPath`);\n                lastPathNode = nextPathNode;\n            }\n            if (this.arity.leading.length > 0 || !this.arity.proxy) {\n                const helpNode = injectNode(machine, makeNode());\n                registerDynamic(machine, lastPathNode, `isHelp`, helpNode, [`useHelp`, this.cliIndex]);\n                registerStatic(machine, helpNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, HELP_COMMAND_INDEX]);\n                this.registerOptions(machine, lastPathNode);\n            }\n            if (this.arity.leading.length > 0)\n                registerStatic(machine, lastPathNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n            let lastLeadingNode = lastPathNode;\n            for (let t = 0; t < this.arity.leading.length; ++t) {\n                const nextLeadingNode = injectNode(machine, makeNode());\n                if (!this.arity.proxy)\n                    this.registerOptions(machine, nextLeadingNode);\n                if (this.arity.trailing.length > 0 || t + 1 !== this.arity.leading.length)\n                    registerStatic(machine, nextLeadingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n                registerDynamic(machine, lastLeadingNode, `isNotOptionLike`, nextLeadingNode, `pushPositional`);\n                lastLeadingNode = nextLeadingNode;\n            }\n            let lastExtraNode = lastLeadingNode;\n            if (this.arity.extra === NoLimits || this.arity.extra.length > 0) {\n                const extraShortcutNode = injectNode(machine, makeNode());\n                registerShortcut(machine, lastLeadingNode, extraShortcutNode);\n                if (this.arity.extra === NoLimits) {\n                    const extraNode = injectNode(machine, makeNode());\n                    if (!this.arity.proxy)\n                        this.registerOptions(machine, extraNode);\n                    registerDynamic(machine, lastLeadingNode, positionalArgument, extraNode, `pushExtra`);\n                    registerDynamic(machine, extraNode, positionalArgument, extraNode, `pushExtra`);\n                    registerShortcut(machine, extraNode, extraShortcutNode);\n                }\n                else {\n                    for (let t = 0; t < this.arity.extra.length; ++t) {\n                        const nextExtraNode = injectNode(machine, makeNode());\n                        if (!this.arity.proxy)\n                            this.registerOptions(machine, nextExtraNode);\n                        registerDynamic(machine, lastExtraNode, positionalArgument, nextExtraNode, `pushExtra`);\n                        registerShortcut(machine, nextExtraNode, extraShortcutNode);\n                        lastExtraNode = nextExtraNode;\n                    }\n                }\n                lastExtraNode = extraShortcutNode;\n            }\n            if (this.arity.trailing.length > 0)\n                registerStatic(machine, lastExtraNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n            let lastTrailingNode = lastExtraNode;\n            for (let t = 0; t < this.arity.trailing.length; ++t) {\n                const nextTrailingNode = injectNode(machine, makeNode());\n                if (!this.arity.proxy)\n                    this.registerOptions(machine, nextTrailingNode);\n                if (t + 1 < this.arity.trailing.length)\n                    registerStatic(machine, nextTrailingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n                registerDynamic(machine, lastTrailingNode, `isNotOptionLike`, nextTrailingNode, `pushPositional`);\n                lastTrailingNode = nextTrailingNode;\n            }\n            registerDynamic(machine, lastTrailingNode, positionalArgument, NODE_ERRORED, [`setError`, `Extraneous positional argument`]);\n            registerStatic(machine, lastTrailingNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, this.cliIndex]);\n        }\n        return {\n            machine,\n            context: this.context,\n        };\n    }\n    registerOptions(machine, node) {\n        registerDynamic(machine, node, [`isOption`, `--`], node, `inhibateOptions`);\n        registerDynamic(machine, node, [`isBatchOption`, this.allOptionNames], node, `pushBatch`);\n        registerDynamic(machine, node, [`isBoundOption`, this.allOptionNames, this.options], node, `pushBound`);\n        registerDynamic(machine, node, [`isUnsupportedOption`, this.allOptionNames], NODE_ERRORED, [`setError`, `Unsupported option name`]);\n        registerDynamic(machine, node, [`isInvalidOption`], NODE_ERRORED, [`setError`, `Invalid option name`]);\n        for (const option of this.options) {\n            const longestName = option.names.reduce((longestName, name) => {\n                return name.length > longestName.length ? name : longestName;\n            }, ``);\n            if (option.arity === 0) {\n                for (const name of option.names) {\n                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], node, `pushTrue`);\n                    if (name.startsWith(`--`)) {\n                        registerDynamic(machine, node, [`isNegatedOption`, name, option.hidden || name !== longestName], node, [`pushFalse`, name]);\n                    }\n                }\n            }\n            else if (option.arity === 1) {\n                const argNode = injectNode(machine, makeNode());\n                registerDynamic(machine, argNode, `isNotOptionLike`, node, `setStringValue`);\n                for (const name of option.names) {\n                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], argNode, `pushUndefined`);\n                }\n            }\n            else {\n                throw new Error(`Unsupported option arity (${option.arity})`);\n            }\n        }\n    }\n}\nclass CliBuilder {\n    constructor({ binaryName = `...` } = {}) {\n        this.builders = [];\n        this.opts = { binaryName };\n    }\n    static build(cbs, opts = {}) {\n        return new CliBuilder(opts).commands(cbs).compile();\n    }\n    getBuilderByIndex(n) {\n        if (!(n >= 0 && n < this.builders.length))\n            throw new Error(`Assertion failed: Out-of-bound command index (${n})`);\n        return this.builders[n];\n    }\n    commands(cbs) {\n        for (const cb of cbs)\n            cb(this.command());\n        return this;\n    }\n    command() {\n        const builder = new CommandBuilder(this.builders.length, this.opts);\n        this.builders.push(builder);\n        return builder;\n    }\n    compile() {\n        const machines = [];\n        const contexts = [];\n        for (const builder of this.builders) {\n            const { machine, context } = builder.compile();\n            machines.push(machine);\n            contexts.push(context);\n        }\n        const machine = makeAnyOfMachine(machines);\n        simplifyMachine(machine);\n        return {\n            machine,\n            contexts,\n            process: (input) => {\n                return runMachine(machine, input);\n            },\n            suggest: (input, partial) => {\n                return suggestMachine(machine, input, partial);\n            },\n        };\n    }\n}\n\nconst richFormat = {\n    bold: str => `\\x1b[1m${str}\\x1b[22m`,\n    error: str => `\\x1b[31m\\x1b[1m${str}\\x1b[22m\\x1b[39m`,\n    code: str => `\\x1b[36m${str}\\x1b[39m`,\n};\nconst textFormat = {\n    bold: str => str,\n    error: str => str,\n    code: str => str,\n};\nfunction formatMarkdownish(text, { format, paragraphs }) {\n    // Enforce \\n as newline character\n    text = text.replace(/\\r\\n?/g, `\\n`);\n    // Remove the indentation, since it got messed up with the JS indentation\n    text = text.replace(/^[\\t ]+|[\\t ]+$/gm, ``);\n    // Remove surrounding newlines, since they got added for JS formatting\n    text = text.replace(/^\\n+|\\n+$/g, ``);\n    // List items always end with at least two newlines (in order to not be collapsed)\n    text = text.replace(/^-([^\\n]*?)\\n+/gm, `-$1\\n\\n`);\n    // Single newlines are removed; larger than that are collapsed into one\n    text = text.replace(/\\n(\\n)?\\n*/g, `$1`);\n    if (paragraphs) {\n        text = text.split(/\\n/).map(function (paragraph) {\n            // Does the paragraph starts with a list?\n            let bulletMatch = paragraph.match(/^[*-][\\t ]+(.*)/);\n            if (!bulletMatch)\n                // No, cut the paragraphs into segments of 80 characters\n                return paragraph.match(/(.{1,80})(?: |$)/g).join(\'\\n\');\n            // Yes, cut the paragraphs into segments of 78 characters (to account for the prefix)\n            return bulletMatch[1].match(/(.{1,78})(?: |$)/g).map((line, index) => {\n                return (index === 0 ? `- ` : `  `) + line;\n            }).join(`\\n`);\n        }).join(`\\n\\n`);\n    }\n    // Highlight the code segments\n    text = text.replace(/(`+)((?:.|[\\n])*?)\\1/g, function ($0, $1, $2) {\n        return format.code($1 + $2 + $1);\n    });\n    return text ? text + `\\n` : ``;\n}\n\nclass HelpCommand$1 extends Command {\n    constructor(realCli, contexts) {\n        super();\n        this.realCli = realCli;\n        this.contexts = contexts;\n        this.commands = [];\n    }\n    static from(state, realCli, contexts) {\n        const command = new HelpCommand$1(realCli, contexts);\n        for (const opt of state.options) {\n            switch (opt.name) {\n                case `-c`:\n                    {\n                        command.commands.push(Number(opt.value));\n                    }\n                    break;\n                case `-i`:\n                    {\n                        command.index = Number(opt.value);\n                    }\n                    break;\n            }\n        }\n        return command;\n    }\n    async execute() {\n        let commands = this.commands;\n        if (typeof this.index !== `undefined` && this.index >= 0 && this.index < commands.length)\n            commands = [commands[this.index]];\n        if (commands.length === 1) {\n            this.context.stdout.write(this.realCli.usage(this.contexts[commands[0]].commandClass, { detailed: true }));\n        }\n        else if (commands.length > 1) {\n            this.context.stdout.write(`Multiple commands match your selection:\\n`);\n            this.context.stdout.write(`\\n`);\n            let index = 0;\n            for (const command of this.commands)\n                this.context.stdout.write(this.realCli.usage(this.contexts[command].commandClass, { prefix: `${index++}. `.padStart(5) }));\n            this.context.stdout.write(`\\n`);\n            this.context.stdout.write(`Run again with -h=<index> to see the longer details of any of those commands.\\n`);\n        }\n    }\n}\n\nfunction getDefaultColorSettings() {\n    if (process.env.FORCE_COLOR === `0`)\n        return false;\n    if (process.env.FORCE_COLOR === `1`)\n        return true;\n    if (typeof process.stdout !== `undefined` && process.stdout.isTTY)\n        return true;\n    return false;\n}\n/**\n * @template Context The context shared by all commands. Contexts are a set of values, defined when calling the `run`/`runExit` functions from the CLI instance, that will be made available to the commands via `this.context`.\n */\nclass Cli {\n    constructor({ binaryLabel, binaryName: binaryNameOpt = `...`, binaryVersion, enableColors = getDefaultColorSettings() } = {}) {\n        this.registrations = new Map();\n        this.builder = new CliBuilder({ binaryName: binaryNameOpt });\n        this.binaryLabel = binaryLabel;\n        this.binaryName = binaryNameOpt;\n        this.binaryVersion = binaryVersion;\n        this.enableColors = enableColors;\n    }\n    /**\n     * Creates a new Cli and registers all commands passed as parameters.\n     *\n     * @param commandClasses The Commands to register\n     * @returns The created `Cli` instance\n     */\n    static from(commandClasses) {\n        const cli = new Cli();\n        for (const commandClass of commandClasses)\n            cli.register(commandClass);\n        return cli;\n    }\n    /**\n     * Registers a command inside the CLI.\n     */\n    register(commandClass) {\n        const commandBuilder = this.builder.command();\n        this.registrations.set(commandClass, commandBuilder.cliIndex);\n        const { definitions } = commandClass.resolveMeta(commandClass.prototype);\n        for (const definition of definitions)\n            definition(commandBuilder);\n        commandBuilder.setContext({\n            commandClass,\n        });\n    }\n    process(input) {\n        const { contexts, process } = this.builder.compile();\n        const state = process(input);\n        switch (state.selectedIndex) {\n            case HELP_COMMAND_INDEX:\n                {\n                    return HelpCommand$1.from(state, this, contexts);\n                }\n            default:\n                {\n                    const { commandClass } = contexts[state.selectedIndex];\n                    const command = new commandClass();\n                    command.path = state.path;\n                    const { transformers } = commandClass.resolveMeta(commandClass.prototype);\n                    for (const transformer of transformers)\n                        transformer(state, command);\n                    return command;\n                }\n        }\n    }\n    async run(input, context) {\n        let command;\n        if (!Array.isArray(input)) {\n            command = input;\n        }\n        else {\n            try {\n                command = this.process(input);\n            }\n            catch (error) {\n                context.stdout.write(this.error(error));\n                return 1;\n            }\n        }\n        if (command.help) {\n            context.stdout.write(this.usage(command, { detailed: true }));\n            return 0;\n        }\n        command.context = context;\n        command.cli = {\n            binaryLabel: this.binaryLabel,\n            binaryName: this.binaryName,\n            binaryVersion: this.binaryVersion,\n            definitions: () => this.definitions(),\n            error: (error, opts) => this.error(error, opts),\n            process: input => this.process(input),\n            run: (input, subContext) => this.run(input, Object.assign(Object.assign({}, context), subContext)),\n            usage: (command, opts) => this.usage(command, opts),\n        };\n        let exitCode;\n        try {\n            exitCode = await command.validateAndExecute();\n        }\n        catch (error) {\n            context.stdout.write(this.error(error, { command }));\n            return 1;\n        }\n        return exitCode;\n    }\n    /**\n     * Runs a command and exits the current `process` with the exit code returned by the command.\n     *\n     * @param input An array containing the name of the command and its arguments.\n     *\n     * @example\n     * cli.runExit(process.argv.slice(2), Cli.defaultContext)\n     */\n    async runExit(input, context) {\n        process.exitCode = await this.run(input, context);\n    }\n    suggest(input, partial) {\n        const { contexts, process, suggest } = this.builder.compile();\n        return suggest(input, partial);\n    }\n    definitions({ colored = false } = {}) {\n        const data = [];\n        for (const [commandClass, number] of this.registrations) {\n            if (typeof commandClass.usage === `undefined`)\n                continue;\n            const path = this.getUsageByIndex(number, { detailed: false });\n            const usage = this.getUsageByIndex(number, { detailed: true });\n            const category = typeof commandClass.usage.category !== `undefined`\n                ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })\n                : undefined;\n            const description = typeof commandClass.usage.description !== `undefined`\n                ? formatMarkdownish(commandClass.usage.description, { format: this.format(colored), paragraphs: false })\n                : undefined;\n            const details = typeof commandClass.usage.details !== `undefined`\n                ? formatMarkdownish(commandClass.usage.details, { format: this.format(colored), paragraphs: true })\n                : undefined;\n            const examples = typeof commandClass.usage.examples !== `undefined`\n                ? commandClass.usage.examples.map(([label, cli]) => [formatMarkdownish(label, { format: this.format(colored), paragraphs: false }), cli.replace(/\\$0/g, this.binaryName)])\n                : undefined;\n            data.push({ path, usage, category, description, details, examples });\n        }\n        return data;\n    }\n    usage(command = null, { colored, detailed = false, prefix = `$ ` } = {}) {\n        // @ts-ignore\n        const commandClass = command !== null && typeof command.getMeta === `undefined`\n            ? command.constructor\n            : command;\n        let result = ``;\n        if (!commandClass) {\n            const commandsByCategories = new Map();\n            for (const [commandClass, number] of this.registrations.entries()) {\n                if (typeof commandClass.usage === `undefined`)\n                    continue;\n                const category = typeof commandClass.usage.category !== `undefined`\n                    ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })\n                    : null;\n                let categoryCommands = commandsByCategories.get(category);\n                if (typeof categoryCommands === `undefined`)\n                    commandsByCategories.set(category, categoryCommands = []);\n                const usage = this.getUsageByIndex(number);\n                categoryCommands.push({ commandClass, usage });\n            }\n            const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {\n                if (a === null)\n                    return -1;\n                if (b === null)\n                    return +1;\n                return a.localeCompare(b, `en`, { usage: `sort`, caseFirst: `upper` });\n            });\n            const hasLabel = typeof this.binaryLabel !== `undefined`;\n            const hasVersion = typeof this.binaryVersion !== `undefined`;\n            if (hasLabel || hasVersion) {\n                if (hasLabel && hasVersion)\n                    result += `${this.format(colored).bold(`${this.binaryLabel} - ${this.binaryVersion}`)}\\n\\n`;\n                else if (hasLabel)\n                    result += `${this.format(colored).bold(`${this.binaryLabel}`)}\\n`;\n                else\n                    result += `${this.format(colored).bold(`${this.binaryVersion}`)}\\n`;\n                result += `  ${this.format(colored).bold(prefix)}${this.binaryName} <command>\\n`;\n            }\n            else {\n                result += `${this.format(colored).bold(prefix)}${this.binaryName} <command>\\n`;\n            }\n            for (let categoryName of categoryNames) {\n                const commands = commandsByCategories.get(categoryName).slice().sort((a, b) => {\n                    return a.usage.localeCompare(b.usage, `en`, { usage: `sort`, caseFirst: `upper` });\n                });\n                const header = categoryName !== null\n                    ? categoryName.trim()\n                    : `Where <command> is one of`;\n                result += `\\n`;\n                result += `${this.format(colored).bold(`${header}:`)}\\n`;\n                for (let { commandClass, usage } of commands) {\n                    const doc = commandClass.usage.description || `undocumented`;\n                    result += `\\n`;\n                    result += `  ${this.format(colored).bold(usage)}\\n`;\n                    result += `    ${formatMarkdownish(doc, { format: this.format(colored), paragraphs: false })}`;\n                }\n            }\n            result += `\\n`;\n            result += formatMarkdownish(`You can also print more details about any of these commands by calling them after adding the \\`-h,--help\\` flag right after the command name.`, { format: this.format(colored), paragraphs: true });\n        }\n        else {\n            if (!detailed) {\n                result += `${this.format(colored).bold(prefix)}${this.getUsageByRegistration(commandClass)}\\n`;\n            }\n            else {\n                const { description = ``, details = ``, examples = [], } = commandClass.usage || {};\n                if (description !== ``) {\n                    result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false }).replace(/^./, $0 => $0.toUpperCase());\n                    result += `\\n`;\n                }\n                if (details !== `` || examples.length > 0) {\n                    result += `${this.format(colored).bold(`Usage:`)}\\n`;\n                    result += `\\n`;\n                }\n                result += `${this.format(colored).bold(prefix)}${this.getUsageByRegistration(commandClass)}\\n`;\n                if (details !== ``) {\n                    result += `\\n`;\n                    result += `${this.format(colored).bold(`Details:`)}\\n`;\n                    result += `\\n`;\n                    result += formatMarkdownish(details, { format: this.format(colored), paragraphs: true });\n                }\n                if (examples.length > 0) {\n                    result += `\\n`;\n                    result += `${this.format(colored).bold(`Examples:`)}\\n`;\n                    for (let [description, example] of examples) {\n                        result += `\\n`;\n                        result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false });\n                        result += example\n                            .replace(/^/m, `  ${this.format(colored).bold(prefix)}`)\n                            .replace(/\\$0/g, this.binaryName)\n                            + `\\n`;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    error(error, { colored, command = null } = {}) {\n        if (!(error instanceof Error))\n            error = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(error)})`);\n        let result = ``;\n        let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);\n        if (name === `Error`)\n            name = `Internal Error`;\n        result += `${this.format(colored).error(name)}: ${error.message}\\n`;\n        // @ts-ignore\n        const meta = error.clipanion;\n        if (typeof meta !== `undefined`) {\n            if (meta.type === `usage`) {\n                result += `\\n`;\n                result += this.usage(command);\n            }\n        }\n        else {\n            if (error.stack) {\n                result += `${error.stack.replace(/^.*\\n/, ``)}\\n`;\n            }\n        }\n        return result;\n    }\n    getUsageByRegistration(klass, opts) {\n        const index = this.registrations.get(klass);\n        if (typeof index === `undefined`)\n            throw new Error(`Assertion failed: Unregistered command`);\n        return this.getUsageByIndex(index, opts);\n    }\n    getUsageByIndex(n, opts) {\n        return this.builder.getBuilderByIndex(n).usage(opts);\n    }\n    format(colored = this.enableColors) {\n        return colored ? richFormat : textFormat;\n    }\n}\n/**\n * The default context of the CLI.\n *\n * Contains the stdio of the current `process`.\n */\nCli.defaultContext = {\n    stdin: process.stdin,\n    stdout: process.stdout,\n    stderr: process.stderr,\n};\n\nCommand.Entries.Help = HelpCommand;\nCommand.Entries.Version = VersionCommand;\n\nexports.Cli = Cli;\nexports.Command = Command;\nexports.UsageError = UsageError;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js?'
				);

				/***/
			},

		/***/ './.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js':
			/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js ***!
  \*****************************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = __webpack_require__(/*! color-name */ \"./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js':
			/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js ***!
  \***********************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"const conversions = __webpack_require__(/*! ./conversions */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js\");\nconst route = __webpack_require__(/*! ./route */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js\");\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js':
			/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js ***!
  \***********************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"const conversions = __webpack_require__(/*! ./conversions */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js\");\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js':
			/*!*****************************************************************************************************!*\
  !*** ./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js ***!
  \*****************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'\r\n\r\nmodule.exports = {\r\n\t"aliceblue": [240, 248, 255],\r\n\t"antiquewhite": [250, 235, 215],\r\n\t"aqua": [0, 255, 255],\r\n\t"aquamarine": [127, 255, 212],\r\n\t"azure": [240, 255, 255],\r\n\t"beige": [245, 245, 220],\r\n\t"bisque": [255, 228, 196],\r\n\t"black": [0, 0, 0],\r\n\t"blanchedalmond": [255, 235, 205],\r\n\t"blue": [0, 0, 255],\r\n\t"blueviolet": [138, 43, 226],\r\n\t"brown": [165, 42, 42],\r\n\t"burlywood": [222, 184, 135],\r\n\t"cadetblue": [95, 158, 160],\r\n\t"chartreuse": [127, 255, 0],\r\n\t"chocolate": [210, 105, 30],\r\n\t"coral": [255, 127, 80],\r\n\t"cornflowerblue": [100, 149, 237],\r\n\t"cornsilk": [255, 248, 220],\r\n\t"crimson": [220, 20, 60],\r\n\t"cyan": [0, 255, 255],\r\n\t"darkblue": [0, 0, 139],\r\n\t"darkcyan": [0, 139, 139],\r\n\t"darkgoldenrod": [184, 134, 11],\r\n\t"darkgray": [169, 169, 169],\r\n\t"darkgreen": [0, 100, 0],\r\n\t"darkgrey": [169, 169, 169],\r\n\t"darkkhaki": [189, 183, 107],\r\n\t"darkmagenta": [139, 0, 139],\r\n\t"darkolivegreen": [85, 107, 47],\r\n\t"darkorange": [255, 140, 0],\r\n\t"darkorchid": [153, 50, 204],\r\n\t"darkred": [139, 0, 0],\r\n\t"darksalmon": [233, 150, 122],\r\n\t"darkseagreen": [143, 188, 143],\r\n\t"darkslateblue": [72, 61, 139],\r\n\t"darkslategray": [47, 79, 79],\r\n\t"darkslategrey": [47, 79, 79],\r\n\t"darkturquoise": [0, 206, 209],\r\n\t"darkviolet": [148, 0, 211],\r\n\t"deeppink": [255, 20, 147],\r\n\t"deepskyblue": [0, 191, 255],\r\n\t"dimgray": [105, 105, 105],\r\n\t"dimgrey": [105, 105, 105],\r\n\t"dodgerblue": [30, 144, 255],\r\n\t"firebrick": [178, 34, 34],\r\n\t"floralwhite": [255, 250, 240],\r\n\t"forestgreen": [34, 139, 34],\r\n\t"fuchsia": [255, 0, 255],\r\n\t"gainsboro": [220, 220, 220],\r\n\t"ghostwhite": [248, 248, 255],\r\n\t"gold": [255, 215, 0],\r\n\t"goldenrod": [218, 165, 32],\r\n\t"gray": [128, 128, 128],\r\n\t"green": [0, 128, 0],\r\n\t"greenyellow": [173, 255, 47],\r\n\t"grey": [128, 128, 128],\r\n\t"honeydew": [240, 255, 240],\r\n\t"hotpink": [255, 105, 180],\r\n\t"indianred": [205, 92, 92],\r\n\t"indigo": [75, 0, 130],\r\n\t"ivory": [255, 255, 240],\r\n\t"khaki": [240, 230, 140],\r\n\t"lavender": [230, 230, 250],\r\n\t"lavenderblush": [255, 240, 245],\r\n\t"lawngreen": [124, 252, 0],\r\n\t"lemonchiffon": [255, 250, 205],\r\n\t"lightblue": [173, 216, 230],\r\n\t"lightcoral": [240, 128, 128],\r\n\t"lightcyan": [224, 255, 255],\r\n\t"lightgoldenrodyellow": [250, 250, 210],\r\n\t"lightgray": [211, 211, 211],\r\n\t"lightgreen": [144, 238, 144],\r\n\t"lightgrey": [211, 211, 211],\r\n\t"lightpink": [255, 182, 193],\r\n\t"lightsalmon": [255, 160, 122],\r\n\t"lightseagreen": [32, 178, 170],\r\n\t"lightskyblue": [135, 206, 250],\r\n\t"lightslategray": [119, 136, 153],\r\n\t"lightslategrey": [119, 136, 153],\r\n\t"lightsteelblue": [176, 196, 222],\r\n\t"lightyellow": [255, 255, 224],\r\n\t"lime": [0, 255, 0],\r\n\t"limegreen": [50, 205, 50],\r\n\t"linen": [250, 240, 230],\r\n\t"magenta": [255, 0, 255],\r\n\t"maroon": [128, 0, 0],\r\n\t"mediumaquamarine": [102, 205, 170],\r\n\t"mediumblue": [0, 0, 205],\r\n\t"mediumorchid": [186, 85, 211],\r\n\t"mediumpurple": [147, 112, 219],\r\n\t"mediumseagreen": [60, 179, 113],\r\n\t"mediumslateblue": [123, 104, 238],\r\n\t"mediumspringgreen": [0, 250, 154],\r\n\t"mediumturquoise": [72, 209, 204],\r\n\t"mediumvioletred": [199, 21, 133],\r\n\t"midnightblue": [25, 25, 112],\r\n\t"mintcream": [245, 255, 250],\r\n\t"mistyrose": [255, 228, 225],\r\n\t"moccasin": [255, 228, 181],\r\n\t"navajowhite": [255, 222, 173],\r\n\t"navy": [0, 0, 128],\r\n\t"oldlace": [253, 245, 230],\r\n\t"olive": [128, 128, 0],\r\n\t"olivedrab": [107, 142, 35],\r\n\t"orange": [255, 165, 0],\r\n\t"orangered": [255, 69, 0],\r\n\t"orchid": [218, 112, 214],\r\n\t"palegoldenrod": [238, 232, 170],\r\n\t"palegreen": [152, 251, 152],\r\n\t"paleturquoise": [175, 238, 238],\r\n\t"palevioletred": [219, 112, 147],\r\n\t"papayawhip": [255, 239, 213],\r\n\t"peachpuff": [255, 218, 185],\r\n\t"peru": [205, 133, 63],\r\n\t"pink": [255, 192, 203],\r\n\t"plum": [221, 160, 221],\r\n\t"powderblue": [176, 224, 230],\r\n\t"purple": [128, 0, 128],\r\n\t"rebeccapurple": [102, 51, 153],\r\n\t"red": [255, 0, 0],\r\n\t"rosybrown": [188, 143, 143],\r\n\t"royalblue": [65, 105, 225],\r\n\t"saddlebrown": [139, 69, 19],\r\n\t"salmon": [250, 128, 114],\r\n\t"sandybrown": [244, 164, 96],\r\n\t"seagreen": [46, 139, 87],\r\n\t"seashell": [255, 245, 238],\r\n\t"sienna": [160, 82, 45],\r\n\t"silver": [192, 192, 192],\r\n\t"skyblue": [135, 206, 235],\r\n\t"slateblue": [106, 90, 205],\r\n\t"slategray": [112, 128, 144],\r\n\t"slategrey": [112, 128, 144],\r\n\t"snow": [255, 250, 250],\r\n\t"springgreen": [0, 255, 127],\r\n\t"steelblue": [70, 130, 180],\r\n\t"tan": [210, 180, 140],\r\n\t"teal": [0, 128, 128],\r\n\t"thistle": [216, 191, 216],\r\n\t"tomato": [255, 99, 71],\r\n\t"turquoise": [64, 224, 208],\r\n\t"violet": [238, 130, 238],\r\n\t"wheat": [245, 222, 179],\r\n\t"white": [255, 255, 255],\r\n\t"whitesmoke": [245, 245, 245],\r\n\t"yellow": [255, 255, 0],\r\n\t"yellowgreen": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js?'
				);

				/***/
			},

		/***/ './.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/index.js':
			/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/index.js ***!
  \*******************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					'\n\nconst cp = __webpack_require__(/*! child_process */ "child_process");\nconst parse = __webpack_require__(/*! ./lib/parse */ "./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/parse.js");\nconst enoent = __webpack_require__(/*! ./lib/enoent */ "./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/enoent.js");\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process "exit" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/index.js?'
				);

				/***/
			},

		/***/ './.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/enoent.js':
			/*!************************************************************************************************************!*\
  !*** ./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/enoent.js ***!
  \************************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					"\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/enoent.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/parse.js':
			/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/parse.js ***!
  \***********************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					"\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst resolveCommand = __webpack_require__(/*! ./util/resolveCommand */ \"./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/resolveCommand.js\");\nconst escape = __webpack_require__(/*! ./util/escape */ \"./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/escape.js\");\nconst readShebang = __webpack_require__(/*! ./util/readShebang */ \"./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/readShebang.js\");\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/parse.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/escape.js':
			/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/escape.js ***!
  \*****************************************************************************************************************/
			/*! default exports */
			/*! export argument [provided] [no usage info] [missing usage info prevents renaming] */
			/*! export command [provided] [no usage info] [missing usage info prevents renaming] */
			/*! other exports [not provided] [no usage info] */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					"\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/escape.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/readShebang.js':
			/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/readShebang.js ***!
  \**********************************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					'\n\nconst fs = __webpack_require__(/*! fs */ "fs");\nconst shebangCommand = __webpack_require__(/*! shebang-command */ "./.yarn/cache/shebang-command-npm-2.0.0-eb2b01921d-85aa394d8c.zip/node_modules/shebang-command/index.js");\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, \'r\');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/readShebang.js?'
				);

				/***/
			},

		/***/ './.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/resolveCommand.js':
			/*!*************************************************************************************************************************!*\
  !*** ./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/resolveCommand.js ***!
  \*************************************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					'\n\nconst path = __webpack_require__(/*! path */ "path");\nconst which = __webpack_require__(/*! which */ "./.yarn/cache/which-npm-2.0.2-320ddf72f7-ea9b1db126.zip/node_modules/which/which.js");\nconst getPathKey = __webpack_require__(/*! path-key */ "./.yarn/cache/path-key-npm-3.1.1-0e66ea8321-e44aa3ca9f.zip/node_modules/path-key/index.js");\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : \'\', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/cross-spawn-npm-7.0.3-e4ff3e65b3-51f10036f5.zip/node_modules/cross-spawn/lib/util/resolveCommand.js?'
				);

				/***/
			},

		/***/ './.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js':
			/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js ***!
  \*************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					"\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/index.js':
			/*!*******************************************************************************************!*\
  !*** ./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/index.js ***!
  \*******************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"var fs = __webpack_require__(/*! fs */ \"fs\")\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = __webpack_require__(/*! ./windows.js */ \"./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/windows.js\")\n} else {\n  core = __webpack_require__(/*! ./mode.js */ \"./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/mode.js\")\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/mode.js':
			/*!******************************************************************************************!*\
  !*** ./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/mode.js ***!
  \******************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"module.exports = isexe\nisexe.sync = sync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/mode.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/windows.js':
			/*!*********************************************************************************************!*\
  !*** ./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/windows.js ***!
  \*********************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"module.exports = isexe\nisexe.sync = sync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/windows.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/path-key-npm-3.1.1-0e66ea8321-e44aa3ca9f.zip/node_modules/path-key/index.js':
			/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/path-key-npm-3.1.1-0e66ea8321-e44aa3ca9f.zip/node_modules/path-key/index.js ***!
  \*************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					"\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/path-key-npm-3.1.1-0e66ea8321-e44aa3ca9f.zip/node_modules/path-key/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/shebang-command-npm-2.0.0-eb2b01921d-85aa394d8c.zip/node_modules/shebang-command/index.js':
			/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/shebang-command-npm-2.0.0-eb2b01921d-85aa394d8c.zip/node_modules/shebang-command/index.js ***!
  \***************************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					"\nconst shebangRegex = __webpack_require__(/*! shebang-regex */ \"./.yarn/cache/shebang-regex-npm-3.0.0-899a0cd65e-ea18044ffa.zip/node_modules/shebang-regex/index.js\");\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/shebang-command-npm-2.0.0-eb2b01921d-85aa394d8c.zip/node_modules/shebang-command/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/shebang-regex-npm-3.0.0-899a0cd65e-ea18044ffa.zip/node_modules/shebang-regex/index.js':
			/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/shebang-regex-npm-3.0.0-899a0cd65e-ea18044ffa.zip/node_modules/shebang-regex/index.js ***!
  \***********************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'\nmodule.exports = /^#!(.*)/;\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/shebang-regex-npm-3.0.0-899a0cd65e-ea18044ffa.zip/node_modules/shebang-regex/index.js?'
				);

				/***/
			},

		/***/ './.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js':
			/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js ***!
  \*************************************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				'use strict';
				eval(
					"\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js\");\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js?"
				);

				/***/
			},

		/***/ './.yarn/cache/which-npm-2.0.2-320ddf72f7-ea9b1db126.zip/node_modules/which/which.js':
			/*!*******************************************************************************************!*\
  !*** ./.yarn/cache/which-npm-2.0.2-320ddf72f7-ea9b1db126.zip/node_modules/which/which.js ***!
  \*******************************************************************************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module, __webpack_require__ */
			/***/ (module, __unused_webpack_exports, __webpack_require__) => {
				eval(
					"const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst COLON = isWindows ? ';' : ':'\nconst isexe = __webpack_require__(/*! isexe */ \"./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-7b437980bb.zip/node_modules/isexe/index.js\")\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n\n\n//# sourceURL=webpack://@nodalis/monorepo/./.yarn/cache/which-npm-2.0.2-320ddf72f7-ea9b1db126.zip/node_modules/which/which.js?"
				);

				/***/
			},

		/***/ child_process:
			/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'module.exports = require("child_process");\n\n//# sourceURL=webpack://@nodalis/monorepo/external_%22child_process%22?'
				);

				/***/
			},

		/***/ fs:
			/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'module.exports = require("fs");\n\n//# sourceURL=webpack://@nodalis/monorepo/external_%22fs%22?'
				);

				/***/
			},

		/***/ module:
			/*!*************************!*\
  !*** external "module" ***!
  \*************************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'module.exports = require("module");\n\n//# sourceURL=webpack://@nodalis/monorepo/external_%22module%22?'
				);

				/***/
			},

		/***/ os:
			/*!*********************!*\
  !*** external "os" ***!
  \*********************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'module.exports = require("os");\n\n//# sourceURL=webpack://@nodalis/monorepo/external_%22os%22?'
				);

				/***/
			},

		/***/ path:
			/*!***********************!*\
  !*** external "path" ***!
  \***********************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'module.exports = require("path");\n\n//# sourceURL=webpack://@nodalis/monorepo/external_%22path%22?'
				);

				/***/
			},

		/***/ tty:
			/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
			/*! unknown exports (runtime-defined) */
			/*! runtime requirements: module */
			/***/ (module) => {
				'use strict';
				eval(
					'module.exports = require("tty");\n\n//# sourceURL=webpack://@nodalis/monorepo/external_%22tty%22?'
				);

				/***/
			},

		/******/
	}; // The module cache
	/************************************************************************/
	/******/ /******/ var __webpack_module_cache__ = {}; // The require function
	/******/
	/******/ /******/ function __webpack_require__(moduleId) {
		/******/ // Check if module is in cache
		/******/ if (__webpack_module_cache__[moduleId]) {
			/******/ return __webpack_module_cache__[moduleId].exports;
			/******/
		} // Create a new module (and put it into the cache)
		/******/ /******/ var module = (__webpack_module_cache__[moduleId] = {
			/******/ id: moduleId,
			/******/ loaded: false,
			/******/ exports: {},
			/******/
		}); // Execute the module function
		/******/
		/******/ /******/ __webpack_modules__[moduleId].call(
			module.exports,
			module,
			module.exports,
			__webpack_require__
		); // Flag the module as loaded
		/******/
		/******/ /******/ module.loaded = true; // Return the exports of the module
		/******/
		/******/ /******/ return module.exports;
		/******/
	} /* webpack/runtime/node module decorator */
	/******/
	/************************************************************************/
	/******/ /******/ (() => {
		/******/ __webpack_require__.nmd = (module) => {
			/******/ module.paths = [];
			/******/ if (!module.children) module.children = [];
			/******/ return module;
			/******/
		};
		/******/
	})(); // module exports must be returned from runtime so entry inlining is disabled // startup // Load entry module and return exports
	/******/
	/************************************************************************/
	/******/ /******/ /******/ /******/ return __webpack_require__(
		'./packages/nodalis-cli/sources/index.ts'
	);
	/******/
})();
