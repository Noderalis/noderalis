/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./packages/noderalis-builder/sources/commands/BuildCommand.ts":
/*!*********************************************************************!*\
  !*** ./packages/noderalis-builder/sources/commands/BuildCommand.ts ***!
  \*********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BuildCommand = void 0;\nconst clipanion_1 = __webpack_require__(/*! clipanion */ \"./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js\");\nconst makeConfig_1 = __webpack_require__(/*! ../tools/makeConfig */ \"./packages/noderalis-builder/sources/tools/makeConfig.ts\");\nclass BuildCommand extends clipanion_1.Command {\n    async execute() {\n        this.context.stdout.write('Hello, Bob!\\n');\n        // Generate a new webpack config, write it to a file, cross-spawn webpack\n        new makeConfig_1.WebpackConfiguration().run();\n    }\n}\n__decorate([\n    clipanion_1.Command.Path('build')\n], BuildCommand.prototype, \"execute\", null);\nexports.BuildCommand = BuildCommand;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-builder/sources/commands/BuildCommand.ts?");

/***/ }),

/***/ "./packages/noderalis-builder/sources/index.ts":
/*!*****************************************************!*\
  !*** ./packages/noderalis-builder/sources/index.ts ***!
  \*****************************************************/
/*! flagged exports */
/*! export __esModule [provided] [maybe used (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used (runtime-defined)] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst clipanion_1 = __webpack_require__(/*! clipanion */ \"./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js\");\nconst BuildCommand_1 = __webpack_require__(/*! ./commands/BuildCommand */ \"./packages/noderalis-builder/sources/commands/BuildCommand.ts\");\nconst script = new clipanion_1.Cli({\n    binaryLabel: 'builder',\n    binaryName: 'builder',\n    binaryVersion: '1.0',\n});\nscript.register(BuildCommand_1.BuildCommand);\nscript.run(process.argv.slice(2), clipanion_1.Cli.defaultContext);\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-builder/sources/index.ts?");

/***/ }),

/***/ "./packages/noderalis-builder/sources/tools/makeConfig.ts":
/*!****************************************************************!*\
  !*** ./packages/noderalis-builder/sources/tools/makeConfig.ts ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebpackConfiguration = void 0;\nconst core_1 = __webpack_require__(/*! @noderalis/core */ \"./packages/noderalis-core/sources/index.ts\");\nconst util_1 = __importDefault(__webpack_require__(/*! util */ \"util\"));\nconst webpack_1 = __importStar(__webpack_require__(/*! webpack */ \"webpack\"));\nconst webpack_merge_1 = __webpack_require__(/*! webpack-merge */ \"./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/index.js\");\nclass WebpackConfiguration {\n    async createEntry(workspace) {\n        console.log(\"Getting roots\\n\");\n        const workspaceKebab = workspace.replace(\"@\", \"\").replace(\"/\", \"-\");\n        const obj = core_1.identity({\n            entry: {\n                [workspaceKebab]: await core_1.ProjectConfiguration.workspace(workspace),\n            },\n            output: {\n                libraryTarget: \"commonjs2\",\n                filename: \"[name].js\",\n                path: await core_1.ProjectConfiguration.resolveProjectWorkspace(workspace, \"lib\"),\n            },\n        });\n        console.log(util_1.default.inspect(obj, { colors: true, depth: Infinity }));\n        return obj;\n    }\n    async create() {\n        const baseConfig = core_1.identity({\n            module: {\n                rules: [\n                    {\n                        test: /\\.tsx?$/,\n                        loader: \"ts-loader\",\n                        options: core_1.identity({\n                            // configFile: resolve(__dirname, '../../../..', 'tsconfig.json'),\n                            happyPackMode: true,\n                        }),\n                    },\n                ],\n            },\n            bail: true,\n            externals: {\n                webpack: \"webpack\",\n                typescript: \"typescript\",\n            },\n            plugins: [\n                new webpack_1.ProgressPlugin({\n                    entries: true,\n                    modules: true,\n                    activeModules: true,\n                }),\n            ],\n            mode: \"development\",\n            resolve: {\n                extensions: [\".ts\", \".tsx\", \".js\", \".json\"],\n            },\n            target: \"async-node\",\n        });\n        const configs = [\n            webpack_merge_1.merge(baseConfig, await this.createEntry(\"@noderalis/builder\")),\n            webpack_merge_1.merge(baseConfig, await this.createEntry(\"@noderalis/cli\")),\n            webpack_merge_1.merge(baseConfig, await this.createEntry(\"@noderalis/core\")),\n        ];\n        console.log(util_1.default.inspect(configs, { colors: true, depth: Infinity }));\n        return configs;\n    }\n    async run() {\n        const compiler = webpack_1.default(await this.create());\n        compiler.run((err, stats) => {\n            if (err)\n                throw err;\n            if (stats) {\n                if (stats.hasErrors()) {\n                    stats.stats.forEach((entryStats) => {\n                        console.error(\"Errors found: \" + util_1.default.inspect(entryStats.compilation.errors));\n                    });\n                }\n            }\n            console.log(\"Compilation complete! No errors to report.\");\n        });\n    }\n}\nexports.WebpackConfiguration = WebpackConfiguration;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-builder/sources/tools/makeConfig.ts?");

/***/ }),

/***/ "./packages/noderalis-core/sources/AbstractConfiguration.ts":
/*!******************************************************************!*\
  !*** ./packages/noderalis-core/sources/AbstractConfiguration.ts ***!
  \******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbstractConfiguration = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nclass AbstractConfiguration {\n    identity(value) {\n        return value;\n    }\n    findConfig(config) {\n        return config;\n    }\n    findProjectCwd(startingCwd) {\n        let projectCwd = null;\n        let nextCwd = startingCwd;\n        let currentCwd = null;\n        while (nextCwd !== currentCwd) {\n            currentCwd = nextCwd;\n            if (fs_1.default.existsSync(path_1.default.join(currentCwd, 'package.json'))) {\n                console.log(`Found package!`);\n                projectCwd = currentCwd;\n            }\n            if (fs_1.default.existsSync(path_1.default.join(currentCwd, '.noderalis.ts'))) {\n                console.log(`Found config!`);\n                projectCwd = currentCwd;\n                break;\n            }\n            if (projectCwd !== null) {\n                break;\n            }\n            nextCwd = path_1.default.dirname(currentCwd);\n        }\n        return projectCwd;\n    }\n}\nexports.AbstractConfiguration = AbstractConfiguration;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-core/sources/AbstractConfiguration.ts?");

/***/ }),

/***/ "./packages/noderalis-core/sources/CommandContext.ts":
/*!***********************************************************!*\
  !*** ./packages/noderalis-core/sources/CommandContext.ts ***!
  \***********************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-core/sources/CommandContext.ts?");

/***/ }),

/***/ "./packages/noderalis-core/sources/NoderalisConfig.ts":
/*!************************************************************!*\
  !*** ./packages/noderalis-core/sources/NoderalisConfig.ts ***!
  \************************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-core/sources/NoderalisConfig.ts?");

/***/ }),

/***/ "./packages/noderalis-core/sources/ProjectConfiguration.ts":
/*!*****************************************************************!*\
  !*** ./packages/noderalis-core/sources/ProjectConfiguration.ts ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProjectConfiguration = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst module_1 = __webpack_require__(/*! module */ \"module\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst AbstractConfiguration_1 = __webpack_require__(/*! ./AbstractConfiguration */ \"./packages/noderalis-core/sources/AbstractConfiguration.ts\");\n// Dangerously setup our resolver\nconst requireAbs = (module_1.createRequire || module_1.createRequireFromPath)(path_1.default.resolve(__dirname, \"./index.ts\"));\nclass ProjectConfiguration extends AbstractConfiguration_1.AbstractConfiguration {\n    constructor(startingCwd) {\n        super();\n        this.cwd = startingCwd;\n    }\n    static async find() {\n        this.requireConfig();\n    }\n    static async requireConfig() {\n        const rootDir = await this.findProjectCwd(process.cwd(), true);\n        let reqConfig = requireAbs(`${rootDir}\\\\noderalis.json`);\n        if (reqConfig.default) {\n            reqConfig = reqConfig.default;\n        }\n        return reqConfig;\n    }\n    /**\n     * Returns an absolute path from within a specified workspace to a specified path.\n     * If using a root related path, use `resolveProjectRoot` instead.\n     * @param workspace the workspace, as defined in `<rootDir>/package.json`, to look for.\n     * @param desiredPath the path or file we're looking for.\n     * @param filename the optional file we're looking for.\n     */\n    static async resolveProjectWorkspace(workspace, desiredPath, filename) {\n        const ws = await this.workspace(workspace, true);\n        const resolvedPath = path_1.default.resolve(ws, filename ? `${desiredPath}/${filename}` : desiredPath);\n        try {\n            if (desiredPath == \"lib\") {\n                fs_1.default.access(resolvedPath, fs_1.default.constants.F_OK, (err) => {\n                    console.log(err);\n                    if (err) {\n                        fs_1.default.mkdirSync(resolvedPath);\n                        return resolvedPath;\n                    }\n                    else {\n                        fs_1.default.accessSync(resolvedPath, fs_1.default.constants.F_OK);\n                        return resolvedPath;\n                    }\n                });\n                return resolvedPath;\n            }\n            else {\n                fs_1.default.accessSync(resolvedPath, fs_1.default.constants.F_OK);\n                return resolvedPath;\n            }\n        }\n        catch (err) {\n            throw `Path \"${resolvedPath}\" does not exist!`;\n        }\n    }\n    /**\n     * Returns an absolute path from the `<rootDir>` to the desired path.\n     * If using a workspace related path, use `resolveProjectWorkspace` instead.\n     * @param desiredPath the path or root file we're looking for.\n     * @param filename the file we're looking for.\n     */\n    static async resolveProjectRoot(desiredPath, filename) {\n        const root = await this.findProjectCwd(process.cwd(), true);\n        const resolvedPath = path_1.default.resolve(root, filename ? `${desiredPath}/${filename}` : desiredPath);\n        // Make sure it exists\n        try {\n            fs_1.default.accessSync(resolvedPath, fs_1.default.constants.F_OK);\n            return resolvedPath;\n        }\n        catch (err) {\n            throw `Path \"${resolvedPath}\" does not exist!`;\n        }\n    }\n    /**\n     * Attempts tp find a workspace from the `workspaces` setting in the root\n     * `package.json` and return it's absolute path.\n     *\n     * - `pkg.workspaces` must exist\n     * - `pkg.main` must point to the workspace entry file\n     *   - i.e. `\"main\": \"./sources/index.ts\"`\n     */\n    static async workspace(workspaceName, returnWorkspacePath) {\n        const rootDir = await this.findProjectCwd(process.cwd(), true);\n        let currentCwd = process.cwd();\n        const data = fs_1.default.readFileSync(path_1.default.resolve(rootDir, \"package.json\"), {\n            encoding: \"utf-8\",\n        });\n        return new Promise(async (resolve, reject) => {\n            const parsedPkg = JSON.parse(data);\n            if (!parsedPkg.workspaces) {\n                throw new Error(\"package.json must include a workspaces setting.\");\n            }\n            parsedPkg.workspaces.forEach((workspaceDir) => {\n                if (workspaceDir.includes(\"*\")) {\n                    // Get the name of the workspaces folder i.e. \"packages/*\" => \"packages\"\n                    const workspace = workspaceDir.slice(0, -2);\n                    // Read each workspace\n                    fs_1.default.readdir(path_1.default.join(rootDir, workspace), async (err, files) => {\n                        if (err)\n                            throw console.log(`Error: ${err}. Files: ${files}`);\n                        for (let i = 0; i < files.length; i++) {\n                            const testDir = path_1.default.join(rootDir, workspace, files[i]);\n                            currentCwd = testDir;\n                            const workspacePkg = await JSON.parse(fs_1.default.readFileSync(`${currentCwd}/package.json`, {\n                                encoding: \"utf-8\",\n                            }));\n                            if (workspaceName == workspacePkg.name) {\n                                if (returnWorkspacePath)\n                                    resolve(path_1.default.resolve(currentCwd));\n                                else\n                                    resolve(path_1.default.resolve(currentCwd, workspacePkg.main));\n                            }\n                        }\n                        reject(\"Not a valid workspace!\");\n                    });\n                }\n                else {\n                    // check against named workspaces\n                    resolve(\"\");\n                }\n            });\n        });\n    }\n    /**\n     * Returns the root path or relative project path.\n     * @param startingCwd the directory to start with, safely pass `process.cwd()` when possible.\n     * @param noderalis search for the root directory.\n     */\n    static async findProjectCwd(startingCwd, noderalis = false) {\n        let projectCwd = \"\";\n        let nextCwd = startingCwd;\n        let currentCwd = \"\";\n        while (nextCwd !== currentCwd) {\n            currentCwd = nextCwd;\n            if (fs_1.default.existsSync(path_1.default.join(currentCwd, \"package.json\"))) {\n                projectCwd = currentCwd;\n            }\n            if (noderalis) {\n                if (fs_1.default.existsSync(path_1.default.join(currentCwd, \"noderalis.json\"))) {\n                    projectCwd = currentCwd;\n                    break;\n                }\n            }\n            else {\n                if (projectCwd !== \"\") {\n                    break;\n                }\n            }\n            nextCwd = path_1.default.dirname(currentCwd);\n        }\n        return projectCwd;\n    }\n}\nexports.ProjectConfiguration = ProjectConfiguration;\nasync function testResolveProjectWorkspace() {\n    const builder = await ProjectConfiguration.resolveProjectWorkspace(\"@noderalis/core\", \"lib\");\n    console.log(\"BuilderLocation: \" + builder);\n}\ntestResolveProjectWorkspace().catch((err) => {\n    console.error(err);\n});\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-core/sources/ProjectConfiguration.ts?");

/***/ }),

/***/ "./packages/noderalis-core/sources/env.ts":
/*!************************************************!*\
  !*** ./packages/noderalis-core/sources/env.ts ***!
  \************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.identity = exports.notImpl = exports.env = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js\"));\nexports.env = {\n    /** Are we running in `development`? */\n    isDevelopment: process.env.BUILD_ENV == 'development',\n    /** Are we running in `production`? */\n    isProduction: process.env.BUILD_ENV == 'production',\n};\nexports.notImpl = chalk_1.default `Not Yet Implemented. Expected by {cyan v1.0.0}`;\nexports.identity = (value) => value;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-core/sources/env.ts?");

/***/ }),

/***/ "./packages/noderalis-core/sources/index.ts":
/*!**************************************************!*\
  !*** ./packages/noderalis-core/sources/index.ts ***!
  \**************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./NoderalisConfig */ \"./packages/noderalis-core/sources/NoderalisConfig.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./env */ \"./packages/noderalis-core/sources/env.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./ProjectConfiguration */ \"./packages/noderalis-core/sources/ProjectConfiguration.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./CommandContext */ \"./packages/noderalis-core/sources/CommandContext.ts\"), exports);\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./packages/noderalis-core/sources/index.ts?");

/***/ }),

/***/ "./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js":
/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js ***!
  \*******************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module.loaded, module.id, module, __webpack_require__.nmd, __webpack_require__, __webpack_require__.* */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst wrapAnsi16 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => (...args) => {\n\tconst rgb = fn(...args);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nconst ansi2ansi = n => n;\nconst rgb2rgb = (r, g, b) => [r, g, b];\n\nconst setLazyProperty = (object, property, get) => {\n\tObject.defineProperty(object, property, {\n\t\tget: () => {\n\t\t\tconst value = get();\n\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\treturn value;\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n};\n\n/** @type {typeof import('color-convert')} */\nlet colorConvert;\nconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\tif (colorConvert === undefined) {\n\t\tcolorConvert = __webpack_require__(/*! color-convert */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js\");\n\t}\n\n\tconst offset = isBackground ? 10 : 0;\n\tconst styles = {};\n\n\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\tif (sourceSpace === targetSpace) {\n\t\t\tstyles[name] = wrap(identity, offset);\n\t\t} else if (typeof suite === 'object') {\n\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t}\n\t}\n\n\treturn styles;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js?");

/***/ }),

/***/ "./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js":
/*!**************************************************************************************************!*\
  !*** ./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js ***!
  \**************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst ansiStyles = __webpack_require__(/*! ansi-styles */ \"./.yarn/cache/ansi-styles-npm-4.2.1-de50ec308d-c8c007d5da.zip/node_modules/ansi-styles/index.js\");\nconst {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(/*! supports-color */ \"./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js\");\nconst {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n} = __webpack_require__(/*! ./util */ \"./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js\");\n\nconst {isArray} = Array;\n\n// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m'\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nclass ChalkClass {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = {};\n\tapplyOptions(chalk, options);\n\n\tchalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);\n\n\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\tObject.setPrototypeOf(chalk.template, chalk);\n\n\tchalk.template.constructor = () => {\n\t\tthrow new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');\n\t};\n\n\tchalk.template.Instance = ChalkClass;\n\n\treturn chalk.template;\n};\n\nfunction Chalk(options) {\n\treturn chalkFactory(options);\n}\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this._styler, true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t}\n};\n\nconst usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nfor (const model of usedModels) {\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this._generator.level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis._generator.level = level;\n\t\t}\n\t}\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\tconst builder = (...arguments_) => {\n\t\tif (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n\t\t\t// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n\t\t\treturn applyStyle(builder, chalkTag(builder, ...arguments_));\n\t\t}\n\n\t\t// Single argument is hot path, implicit coercion is faster than anything\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\treturn applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\t};\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder._generator = self;\n\tbuilder._styler = _styler;\n\tbuilder._isEmpty = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self._isEmpty ? '' : string;\n\t}\n\n\tlet styler = self._styler;\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.indexOf('\\u001B') !== -1) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nlet template;\nconst chalkTag = (chalk, ...strings) => {\n\tconst [firstString] = strings;\n\n\tif (!isArray(firstString) || !isArray(firstString.raw)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn strings.join(' ');\n\t}\n\n\tconst arguments_ = strings.slice(1);\n\tconst parts = [firstString.raw[0]];\n\n\tfor (let i = 1; i < firstString.length; i++) {\n\t\tparts.push(\n\t\t\tString(arguments_[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'),\n\t\t\tString(firstString.raw[i])\n\t\t);\n\t}\n\n\tif (template === undefined) {\n\t\ttemplate = __webpack_require__(/*! ./templates */ \"./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js\");\n\t}\n\n\treturn template(chalk, parts.join(''));\n};\n\nObject.defineProperties(Chalk.prototype, styles);\n\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\n\nmodule.exports = chalk;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/index.js?");

/***/ }),

/***/ "./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js":
/*!******************************************************************************************************!*\
  !*** ./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js ***!
  \******************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tconst u = c[0] === 'u';\n\tconst bracket = c[1] === '{';\n\n\tif ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\tif (u && bracket) {\n\t\treturn String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, arguments_) {\n\tconst results = [];\n\tconst chunks = arguments_.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tconst number = Number(chunk);\n\t\tif (!Number.isNaN(number)) {\n\t\t\tresults.push(number);\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const [styleName, styles] of Object.entries(enabled)) {\n\t\tif (!Array.isArray(styles)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(styleName in current)) {\n\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t}\n\n\t\tcurrent = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, temporary) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttemporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n\t\tif (escapeCharacter) {\n\t\t\tchunk.push(unescape(escapeCharacter));\n\t\t} else if (style) {\n\t\t\tconst string = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(character);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMessage);\n\t}\n\n\treturn chunks.join('');\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/templates.js?");

/***/ }),

/***/ "./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js":
/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js ***!
  \*************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("\n\nconst stringReplaceAll = (string, substring, replacer) => {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nmodule.exports = {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/chalk-npm-4.1.0-c746e252ba-f860285b41.zip/node_modules/chalk/source/util.js?");

/***/ }),

/***/ "./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js":
/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js ***!
  \*******************************************************************************************************/
/*! flagged exports */
/*! export Cli [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Command [provided] [no usage info] [missing usage info prevents renaming] */
/*! export UsageError [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nclass Command {\n    constructor() {\n        /**\n         * Predefined that will be set to true if `-h,--help` has been used, in which case `Command#execute` shouldn't be called.\n         */\n        this.help = false;\n    }\n    static getMeta(prototype) {\n        const base = prototype.constructor;\n        return base.meta = Object.prototype.hasOwnProperty.call(base, `meta`) ? base.meta : {\n            definitions: [],\n            transformers: [\n                (state, command) => {\n                    for (const { name, value } of state.options) {\n                        if (name === `-h` || name === `--help`) {\n                            // @ts-ignore: The property is meant to have been defined by the child class\n                            command.help = value;\n                        }\n                    }\n                },\n            ],\n        };\n    }\n    static resolveMeta(prototype) {\n        const definitions = [];\n        const transformers = [];\n        for (let proto = prototype; proto instanceof Command; proto = proto.__proto__) {\n            const meta = this.getMeta(proto);\n            for (const definition of meta.definitions)\n                definitions.push(definition);\n            for (const transformer of meta.transformers) {\n                transformers.push(transformer);\n            }\n        }\n        return {\n            definitions,\n            transformers,\n        };\n    }\n    static registerDefinition(prototype, definition) {\n        this.getMeta(prototype).definitions.push(definition);\n    }\n    static registerTransformer(prototype, transformer) {\n        this.getMeta(prototype).transformers.push(transformer);\n    }\n    static addPath(...path) {\n        this.Path(...path)(this.prototype, `execute`);\n    }\n    static addOption(name, builder) {\n        builder(this.prototype, name);\n    }\n    /**\n     * Wrap the specified command to be attached to the given path on the command line.\n     * The first path thus attached will be considered the \"main\" one, and all others will be aliases.\n     * @param path The command path.\n     */\n    static Path(...path) {\n        return (prototype, propertyName) => {\n            this.registerDefinition(prototype, command => {\n                command.addPath(path);\n            });\n        };\n    }\n    /**\n     * Register a boolean listener for the given option names. When Clipanion detects that this argument is present, the value will be set to false. The value won't be set unless the option is found, so you must remember to set it to an appropriate default value.\n     * @param descriptor the option names.\n     */\n    static Boolean(descriptor, { hidden = false } = {}) {\n        return (prototype, propertyName) => {\n            const optNames = descriptor.split(`,`);\n            this.registerDefinition(prototype, command => {\n                command.addOption({ names: optNames, arity: 0, hidden, allowBinding: false });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                for (const { name, value } of state.options) {\n                    if (optNames.includes(name)) {\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName] = value;\n                    }\n                }\n            });\n        };\n    }\n    static String(descriptor = { required: true }, { tolerateBoolean = false, hidden = false } = {}) {\n        return (prototype, propertyName) => {\n            if (typeof descriptor === `string`) {\n                const optNames = descriptor.split(`,`);\n                this.registerDefinition(prototype, command => {\n                    // If tolerateBoolean is specified, the command will only accept a string value\n                    // using the bind syntax and will otherwise act like a boolean option\n                    command.addOption({ names: optNames, arity: tolerateBoolean ? 0 : 1, hidden });\n                });\n                this.registerTransformer(prototype, (state, command) => {\n                    for (const { name, value } of state.options) {\n                        if (optNames.includes(name)) {\n                            // @ts-ignore: The property is meant to have been defined by the child class\n                            command[propertyName] = value;\n                        }\n                    }\n                });\n            }\n            else {\n                this.registerDefinition(prototype, command => {\n                    command.addPositional({ name: propertyName, required: descriptor.required });\n                });\n                this.registerTransformer(prototype, (state, command) => {\n                    if (state.positionals.length > 0) {\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName] = state.positionals.shift().value;\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be pushed into the array represented in the property.\n     */\n    static Array(descriptor, { hidden = false } = {}) {\n        return (prototype, propertyName) => {\n            const optNames = descriptor.split(`,`);\n            this.registerDefinition(prototype, command => {\n                command.addOption({ names: optNames, arity: 1, hidden });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                for (const { name, value } of state.options) {\n                    if (optNames.includes(name)) {\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName] = command[propertyName] || [];\n                        // @ts-ignore: The property is meant to have been defined by the child class\n                        command[propertyName].push(value);\n                    }\n                }\n            });\n        };\n    }\n    static Rest({ required = 0 } = {}) {\n        return (prototype, propertyName) => {\n            this.registerDefinition(prototype, command => {\n                command.addRest({ name: propertyName, required });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                // @ts-ignore: The property is meant to have been defined by the child class\n                command[propertyName] = state.positionals.map(({ value }) => value);\n            });\n        };\n    }\n    /**\n     * Register a listener that takes all the arguments remaining (including options and such) and store them into the selected property.\n     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).\n     */\n    static Proxy({ required = 0 } = {}) {\n        return (prototype, propertyName) => {\n            this.registerDefinition(prototype, command => {\n                command.addProxy({ required });\n            });\n            this.registerTransformer(prototype, (state, command) => {\n                // @ts-ignore: The property is meant to have been defined by the child class\n                command[propertyName] = state.positionals.map(({ value }) => value);\n            });\n        };\n    }\n    /**\n     * Defines the usage information for the given command.\n     * @param usage\n     */\n    static Usage(usage) {\n        return usage;\n    }\n    /**\n     * Defines the schema for the given command.\n     * @param schema\n     */\n    static Schema(schema) {\n        return schema;\n    }\n    async validateAndExecute() {\n        const commandClass = this.constructor;\n        const schema = commandClass.schema;\n        if (typeof schema !== `undefined`) {\n            try {\n                await schema.validate(this);\n            }\n            catch (error) {\n                if (error.name === `ValidationError`)\n                    error.clipanion = { type: `usage` };\n                throw error;\n            }\n        }\n        const exitCode = await this.execute();\n        if (typeof exitCode !== `undefined`) {\n            return exitCode;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n/**\n * A list of useful semi-opinionated command entries that have to be registered manually.\n *\n * They cover the basic needs of most CLIs (e.g. help command, version command).\n *\n * @example\n * cli.register(Command.Entries.Help);\n * cli.register(Command.Entries.Version);\n */\nCommand.Entries = {};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\n\nclass HelpCommand extends Command {\n    async execute() {\n        this.context.stdout.write(this.cli.usage(null));\n    }\n}\n__decorate([\n    Command.Path(`--help`),\n    Command.Path(`-h`)\n], HelpCommand.prototype, \"execute\", null);\n\nclass VersionCommand extends Command {\n    async execute() {\n        var _a;\n        this.context.stdout.write(`${(_a = this.cli.binaryVersion) !== null && _a !== void 0 ? _a : `<unknown>`}\\n`);\n    }\n}\n__decorate([\n    Command.Path(`--version`),\n    Command.Path(`-v`)\n], VersionCommand.prototype, \"execute\", null);\n\nconst NODE_INITIAL = 0;\nconst NODE_SUCCESS = 1;\nconst NODE_ERRORED = 2;\nconst START_OF_INPUT = `\\u0001`;\nconst END_OF_INPUT = `\\u0000`;\nconst HELP_COMMAND_INDEX = -1;\nconst HELP_REGEX = /^(-h|--help)(?:=([0-9]+))?$/;\nconst OPTION_REGEX = /^(--[a-z]+(?:-[a-z]+)*|-[a-zA-Z]+)$/;\nconst BATCH_REGEX = /^-[a-zA-Z]{2,}$/;\nconst BINDING_REGEX = /^([^=]+)=([\\s\\S]*)$/;\nconst DEBUG = process.env.DEBUG_CLI === `1`;\n\n/**\n * A generic usage error with the name `UsageError`.\n *\n * It should be used over `Error` only when it's the user's fault.\n */\nclass UsageError extends Error {\n    constructor(message) {\n        super(message);\n        this.clipanion = { type: `usage` };\n        this.name = `UsageError`;\n    }\n}\nclass UnknownSyntaxError extends Error {\n    constructor(input, candidates) {\n        super();\n        this.input = input;\n        this.candidates = candidates;\n        this.clipanion = { type: `none` };\n        this.name = `UnknownSyntaxError`;\n        if (this.candidates.length === 0) {\n            this.message = `Command not found, but we're not sure what's the alternative.`;\n        }\n        else if (this.candidates.length === 1 && this.candidates[0].reason !== null) {\n            const [{ usage, reason }] = this.candidates;\n            this.message = `${reason}\\n\\n$ ${usage}`;\n        }\n        else if (this.candidates.length === 1) {\n            const [{ usage }] = this.candidates;\n            this.message = `Command not found; did you mean:\\n\\n$ ${usage}\\n${whileRunning(input)}`;\n        }\n        else {\n            this.message = `Command not found; did you mean one of:\\n\\n${this.candidates.map(({ usage }, index) => {\n                return `${`${index}.`.padStart(4)} ${usage}`;\n            }).join(`\\n`)}\\n\\n${whileRunning(input)}`;\n        }\n    }\n}\nclass AmbiguousSyntaxError extends Error {\n    constructor(input, usages) {\n        super();\n        this.input = input;\n        this.usages = usages;\n        this.clipanion = { type: `none` };\n        this.name = `AmbiguousSyntaxError`;\n        this.message = `Cannot find who to pick amongst the following alternatives:\\n\\n${this.usages.map((usage, index) => {\n            return `${`${index}.`.padStart(4)} ${usage}`;\n        }).join(`\\n`)}\\n\\n${whileRunning(input)}`;\n    }\n}\nconst whileRunning = (input) => `While running ${input.filter(token => {\n    return token !== END_OF_INPUT;\n}).map(token => {\n    const json = JSON.stringify(token);\n    if (token.match(/\\s/) || token.length === 0 || json !== `\"${token}\"`) {\n        return json;\n    }\n    else {\n        return token;\n    }\n}).join(` `)}`;\n\n// ------------------------------------------------------------------------\nfunction debug(str) {\n    if (DEBUG) {\n        console.log(str);\n    }\n}\nfunction makeStateMachine() {\n    return {\n        nodes: [makeNode(), makeNode(), makeNode()],\n    };\n}\nfunction makeAnyOfMachine(inputs) {\n    const output = makeStateMachine();\n    const heads = [];\n    let offset = output.nodes.length;\n    for (const input of inputs) {\n        heads.push(offset);\n        for (let t = 0; t < input.nodes.length; ++t)\n            if (!isTerminalNode(t))\n                output.nodes.push(cloneNode(input.nodes[t], offset));\n        offset += input.nodes.length - 2;\n    }\n    for (const head of heads)\n        registerShortcut(output, NODE_INITIAL, head);\n    return output;\n}\nfunction injectNode(machine, node) {\n    machine.nodes.push(node);\n    return machine.nodes.length - 1;\n}\nfunction simplifyMachine(input) {\n    const visited = new Set();\n    const process = (node) => {\n        if (visited.has(node))\n            return;\n        visited.add(node);\n        const nodeDef = input.nodes[node];\n        for (const transitions of Object.values(nodeDef.statics))\n            for (const { to } of transitions)\n                process(to);\n        for (const [, { to }] of nodeDef.dynamics)\n            process(to);\n        for (const { to } of nodeDef.shortcuts)\n            process(to);\n        const shortcuts = new Set(nodeDef.shortcuts.map(({ to }) => to));\n        while (nodeDef.shortcuts.length > 0) {\n            const { to } = nodeDef.shortcuts.shift();\n            const toDef = input.nodes[to];\n            for (const [segment, transitions] of Object.entries(toDef.statics)) {\n                let store = !Object.prototype.hasOwnProperty.call(nodeDef.statics, segment)\n                    ? nodeDef.statics[segment] = []\n                    : nodeDef.statics[segment];\n                for (const transition of transitions) {\n                    if (!store.some(({ to }) => transition.to === to)) {\n                        store.push(transition);\n                    }\n                }\n            }\n            for (const [test, transition] of toDef.dynamics)\n                if (!nodeDef.dynamics.some(([otherTest, { to }]) => test === otherTest && transition.to === to))\n                    nodeDef.dynamics.push([test, transition]);\n            for (const transition of toDef.shortcuts) {\n                if (!shortcuts.has(transition.to)) {\n                    nodeDef.shortcuts.push(transition);\n                    shortcuts.add(transition.to);\n                }\n            }\n        }\n    };\n    process(NODE_INITIAL);\n}\nfunction debugMachine(machine, { prefix = `` } = {}) {\n    debug(`${prefix}Nodes are:`);\n    for (let t = 0; t < machine.nodes.length; ++t) {\n        debug(`${prefix}  ${t}: ${JSON.stringify(machine.nodes[t])}`);\n    }\n}\nfunction runMachineInternal(machine, input, partial = false) {\n    debug(`Running a vm on ${JSON.stringify(input)}`);\n    let branches = [{ node: NODE_INITIAL, state: {\n                candidateUsage: null,\n                errorMessage: null,\n                ignoreOptions: false,\n                options: [],\n                path: [],\n                positionals: [],\n                remainder: null,\n                selectedIndex: null,\n            } }];\n    debugMachine(machine, { prefix: `  ` });\n    const tokens = [START_OF_INPUT, ...input];\n    for (let t = 0; t < tokens.length; ++t) {\n        const segment = tokens[t];\n        debug(`  Processing ${JSON.stringify(segment)}`);\n        const nextBranches = [];\n        for (const { node, state } of branches) {\n            debug(`    Current node is ${node}`);\n            const nodeDef = machine.nodes[node];\n            if (node === NODE_ERRORED) {\n                nextBranches.push({ node, state });\n                continue;\n            }\n            console.assert(nodeDef.shortcuts.length === 0, `Shortcuts should have been eliminated by now`);\n            const hasExactMatch = Object.prototype.hasOwnProperty.call(nodeDef.statics, segment);\n            if (!partial || t < tokens.length - 1 || hasExactMatch) {\n                if (hasExactMatch) {\n                    const transitions = nodeDef.statics[segment];\n                    for (const { to, reducer } of transitions) {\n                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });\n                        debug(`      Static transition to ${to} found`);\n                    }\n                }\n                else {\n                    debug(`      No static transition found`);\n                }\n            }\n            else {\n                let hasMatches = false;\n                for (const candidate of Object.keys(nodeDef.statics)) {\n                    if (!candidate.startsWith(segment))\n                        continue;\n                    if (segment === candidate) {\n                        for (const { to, reducer } of nodeDef.statics[candidate]) {\n                            nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });\n                            debug(`      Static transition to ${to} found`);\n                        }\n                    }\n                    else {\n                        for (const { to, reducer } of nodeDef.statics[candidate]) {\n                            nextBranches.push({ node: to, state: Object.assign(Object.assign({}, state), { remainder: candidate.slice(segment.length) }) });\n                            debug(`      Static transition to ${to} found (partial match)`);\n                        }\n                    }\n                    hasMatches = true;\n                }\n                if (!hasMatches) {\n                    debug(`      No partial static transition found`);\n                }\n            }\n            if (segment !== END_OF_INPUT) {\n                for (const [test, { to, reducer }] of nodeDef.dynamics) {\n                    if (execute(tests, test, state, segment)) {\n                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });\n                        debug(`      Dynamic transition to ${to} found (via ${test})`);\n                    }\n                }\n            }\n        }\n        if (nextBranches.length === 0) {\n            throw new UnknownSyntaxError(input, branches.filter(({ node }) => {\n                return node !== NODE_ERRORED;\n            }).map(({ state }) => {\n                return { usage: state.candidateUsage, reason: null };\n            }));\n        }\n        if (nextBranches.every(({ node }) => node === NODE_ERRORED)) {\n            throw new UnknownSyntaxError(input, nextBranches.map(({ state }) => {\n                return { usage: state.candidateUsage, reason: state.errorMessage };\n            }));\n        }\n        branches = trimSmallerBranches(nextBranches);\n    }\n    if (branches.length > 0) {\n        debug(`  Results:`);\n        for (const branch of branches) {\n            debug(`    - ${branch.node} -> ${JSON.stringify(branch.state)}`);\n        }\n    }\n    else {\n        debug(`  No results`);\n    }\n    return branches;\n}\nfunction checkIfNodeIsFinished(node, state) {\n    if (state.selectedIndex !== null)\n        return true;\n    if (Object.prototype.hasOwnProperty.call(node.statics, END_OF_INPUT))\n        for (const { to } of node.statics[END_OF_INPUT])\n            if (to === NODE_SUCCESS)\n                return true;\n    return false;\n}\nfunction suggestMachine(machine, input, partial) {\n    // If we're accepting partial matches, then exact matches need to be\n    // prefixed with an extra space.\n    const prefix = partial && input.length > 0 ? [``] : [];\n    const branches = runMachineInternal(machine, input, partial);\n    const suggestions = [];\n    const suggestionsJson = new Set();\n    const traverseSuggestion = (suggestion, node, skipFirst = true) => {\n        let nextNodes = [node];\n        while (nextNodes.length > 0) {\n            const currentNodes = nextNodes;\n            nextNodes = [];\n            for (const node of currentNodes) {\n                const nodeDef = machine.nodes[node];\n                const keys = Object.keys(nodeDef.statics);\n                for (const key of Object.keys(nodeDef.statics)) {\n                    const segment = keys[0];\n                    for (const { to, reducer } of nodeDef.statics[segment]) {\n                        if (reducer !== `pushPath`)\n                            continue;\n                        if (!skipFirst)\n                            suggestion.push(segment);\n                        nextNodes.push(to);\n                    }\n                }\n            }\n            skipFirst = false;\n        }\n        const json = JSON.stringify(suggestion);\n        if (suggestionsJson.has(json))\n            return;\n        suggestions.push(suggestion);\n        suggestionsJson.add(json);\n    };\n    for (const { node, state } of branches) {\n        if (state.remainder !== null) {\n            traverseSuggestion([state.remainder], node);\n            continue;\n        }\n        const nodeDef = machine.nodes[node];\n        const isFinished = checkIfNodeIsFinished(nodeDef, state);\n        for (const [candidate, transitions] of Object.entries(nodeDef.statics))\n            if ((isFinished && candidate !== END_OF_INPUT) || (!candidate.startsWith(`-`) && transitions.some(({ reducer }) => reducer === `pushPath`)))\n                traverseSuggestion([...prefix, candidate], node);\n        if (!isFinished)\n            continue;\n        for (const [test, { to }] of nodeDef.dynamics) {\n            if (to === NODE_ERRORED)\n                continue;\n            const tokens = suggest(test, state);\n            if (tokens === null)\n                continue;\n            for (const token of tokens) {\n                traverseSuggestion([...prefix, token], node);\n            }\n        }\n    }\n    return [...suggestions].sort();\n}\nfunction runMachine(machine, input) {\n    const branches = runMachineInternal(machine, [...input, END_OF_INPUT]);\n    return selectBestState(input, branches.map(({ state }) => {\n        return state;\n    }));\n}\nfunction trimSmallerBranches(branches) {\n    let maxPathSize = 0;\n    for (const { state } of branches)\n        if (state.path.length > maxPathSize)\n            maxPathSize = state.path.length;\n    return branches.filter(({ state }) => {\n        return state.path.length === maxPathSize;\n    });\n}\nfunction selectBestState(input, states) {\n    const terminalStates = states.filter(state => {\n        return state.selectedIndex !== null;\n    });\n    if (terminalStates.length === 0)\n        throw new Error();\n    let maxPathSize = 0;\n    for (const state of terminalStates)\n        if (state.path.length > maxPathSize)\n            maxPathSize = state.path.length;\n    const bestPathBranches = terminalStates.filter(state => {\n        return state.path.length === maxPathSize;\n    });\n    const getPositionalCount = (state) => state.positionals.filter(({ extra }) => {\n        return !extra;\n    }).length + state.options.length;\n    const statesWithPositionalCount = bestPathBranches.map(state => {\n        return { state, positionalCount: getPositionalCount(state) };\n    });\n    let maxPositionalCount = 0;\n    for (const { positionalCount } of statesWithPositionalCount)\n        if (positionalCount > maxPositionalCount)\n            maxPositionalCount = positionalCount;\n    const bestPositionalStates = statesWithPositionalCount.filter(({ positionalCount }) => {\n        return positionalCount === maxPositionalCount;\n    }).map(({ state }) => {\n        return state;\n    });\n    const fixedStates = aggregateHelpStates(bestPositionalStates);\n    if (fixedStates.length > 1)\n        throw new AmbiguousSyntaxError(input, fixedStates.map(state => state.candidateUsage));\n    return fixedStates[0];\n}\nfunction aggregateHelpStates(states) {\n    const notHelps = [];\n    const helps = [];\n    for (const state of states) {\n        if (state.selectedIndex === HELP_COMMAND_INDEX) {\n            helps.push(...state.options);\n        }\n        else {\n            notHelps.push(state);\n        }\n    }\n    if (helps.length > 0) {\n        notHelps.push({\n            candidateUsage: null,\n            errorMessage: null,\n            ignoreOptions: false,\n            path: [],\n            positionals: [],\n            options: helps,\n            remainder: null,\n            selectedIndex: HELP_COMMAND_INDEX,\n        });\n    }\n    return notHelps;\n}\nfunction makeNode() {\n    return {\n        dynamics: [],\n        shortcuts: [],\n        statics: {},\n    };\n}\nfunction isTerminalNode(node) {\n    return node === NODE_SUCCESS || node === NODE_ERRORED;\n}\nfunction cloneTransition(input, offset = 0) {\n    return {\n        to: !isTerminalNode(input.to) ? input.to > 2 ? input.to + offset - 2 : input.to + offset : input.to,\n        reducer: input.reducer,\n    };\n}\nfunction cloneNode(input, offset = 0) {\n    const output = makeNode();\n    for (const [test, transition] of input.dynamics)\n        output.dynamics.push([test, cloneTransition(transition, offset)]);\n    for (const transition of input.shortcuts)\n        output.shortcuts.push(cloneTransition(transition, offset));\n    for (const [segment, transitions] of Object.entries(input.statics))\n        output.statics[segment] = transitions.map(transition => cloneTransition(transition, offset));\n    return output;\n}\nfunction registerDynamic(machine, from, test, to, reducer) {\n    machine.nodes[from].dynamics.push([test, { to, reducer }]);\n}\nfunction registerShortcut(machine, from, to, reducer) {\n    machine.nodes[from].shortcuts.push({ to, reducer });\n}\nfunction registerStatic(machine, from, test, to, reducer) {\n    let store = !Object.prototype.hasOwnProperty.call(machine.nodes[from].statics, test)\n        ? machine.nodes[from].statics[test] = []\n        : machine.nodes[from].statics[test];\n    store.push({ to, reducer });\n}\nfunction execute(store, callback, state, segment) {\n    if (Array.isArray(callback)) {\n        const [name, ...args] = callback;\n        return store[name](state, segment, ...args);\n    }\n    else {\n        return store[callback](state, segment);\n    }\n}\nfunction suggest(callback, state) {\n    const fn = Array.isArray(callback)\n        ? tests[callback[0]]\n        : tests[callback];\n    // @ts-ignore\n    if (typeof fn.suggest === `undefined`)\n        return null;\n    const args = Array.isArray(callback)\n        ? callback.slice(1)\n        : [];\n    // @ts-ignore\n    return fn.suggest(state, ...args);\n}\nconst tests = {\n    always: () => {\n        return true;\n    },\n    isNotOptionLike: (state, segment) => {\n        return state.ignoreOptions || !segment.startsWith(`-`);\n    },\n    isOption: (state, segment, name, hidden) => {\n        return !state.ignoreOptions && segment === name;\n    },\n    isBatchOption: (state, segment, names) => {\n        return !state.ignoreOptions && BATCH_REGEX.test(segment) && [...segment.slice(1)].every(name => names.includes(`-${name}`));\n    },\n    isBoundOption: (state, segment, names, options) => {\n        const optionParsing = segment.match(BINDING_REGEX);\n        return !state.ignoreOptions && !!optionParsing && OPTION_REGEX.test(optionParsing[1]) && names.includes(optionParsing[1])\n            // Disallow bound options with no arguments (i.e. booleans)\n            && options.filter(opt => opt.names.includes(optionParsing[1])).every(opt => opt.allowBinding);\n    },\n    isNegatedOption: (state, segment, name) => {\n        return !state.ignoreOptions && segment === `--no-${name.slice(2)}`;\n    },\n    isHelp: (state, segment) => {\n        return !state.ignoreOptions && HELP_REGEX.test(segment);\n    },\n    isUnsupportedOption: (state, segment, names) => {\n        return !state.ignoreOptions && segment.startsWith(`-`) && OPTION_REGEX.test(segment) && !names.includes(segment);\n    },\n    isInvalidOption: (state, segment) => {\n        return !state.ignoreOptions && segment.startsWith(`-`) && !OPTION_REGEX.test(segment);\n    },\n};\n// @ts-ignore\ntests.isOption.suggest = (state, name, hidden = true) => {\n    return !hidden ? [name] : null;\n};\nconst reducers = {\n    setCandidateUsage: (state, segment, usage) => {\n        return Object.assign(Object.assign({}, state), { candidateUsage: usage });\n    },\n    setSelectedIndex: (state, segment, index) => {\n        return Object.assign(Object.assign({}, state), { selectedIndex: index });\n    },\n    pushBatch: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat([...segment.slice(1)].map(name => ({ name: `-${name}`, value: true }))) });\n    },\n    pushBound: (state, segment) => {\n        const [, name, value] = segment.match(BINDING_REGEX);\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value }) });\n    },\n    pushPath: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { path: state.path.concat(segment) });\n    },\n    pushPositional: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: false }) });\n    },\n    pushExtra: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: true }) });\n    },\n    pushTrue: (state, segment, name = segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: true }) });\n    },\n    pushFalse: (state, segment, name = segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value: false }) });\n    },\n    pushUndefined: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: undefined }) });\n    },\n    setStringValue: (state, segment) => {\n        return Object.assign(Object.assign({}, state), { options: state.options.slice(0, -1).concat(Object.assign(Object.assign({}, state.options[state.options.length - 1]), { value: segment })) });\n    },\n    inhibateOptions: (state) => {\n        return Object.assign(Object.assign({}, state), { ignoreOptions: true });\n    },\n    useHelp: (state, segment, command) => {\n        const [, name, index] = segment.match(HELP_REGEX);\n        if (typeof index !== `undefined`) {\n            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }, { name: `-i`, value: index }] });\n        }\n        else {\n            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }] });\n        }\n    },\n    setError: (state, segment, errorMessage) => {\n        if (segment === END_OF_INPUT) {\n            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage}.` });\n        }\n        else {\n            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage} (\"${segment}\").` });\n        }\n    },\n};\n// ------------------------------------------------------------------------\nconst NoLimits = Symbol();\nclass CommandBuilder {\n    constructor(cliIndex, cliOpts) {\n        this.allOptionNames = [];\n        this.arity = { leading: [], trailing: [], extra: [], proxy: false };\n        this.options = [];\n        this.paths = [];\n        this.cliIndex = cliIndex;\n        this.cliOpts = cliOpts;\n    }\n    addPath(path) {\n        this.paths.push(path);\n    }\n    setArity({ leading = this.arity.leading, trailing = this.arity.trailing, extra = this.arity.extra, proxy = this.arity.proxy }) {\n        Object.assign(this.arity, { leading, trailing, extra, proxy });\n    }\n    addPositional({ name = 'arg', required = true } = {}) {\n        if (!required && this.arity.extra === NoLimits)\n            throw new Error(`Optional parameters cannot be declared when using .rest() or .proxy()`);\n        if (!required && this.arity.trailing.length > 0)\n            throw new Error(`Optional parameters cannot be declared after the required trailing positional arguments`);\n        if (!required && this.arity.extra !== NoLimits) {\n            this.arity.extra.push(name);\n        }\n        else if (this.arity.extra !== NoLimits && this.arity.extra.length === 0) {\n            this.arity.leading.push(name);\n        }\n        else {\n            this.arity.trailing.push(name);\n        }\n    }\n    addRest({ name = 'arg', required = 0 } = {}) {\n        if (this.arity.extra === NoLimits)\n            throw new Error(`Infinite lists cannot be declared multiple times in the same command`);\n        if (this.arity.trailing.length > 0)\n            throw new Error(`Infinite lists cannot be declared after the required trailing positional arguments`);\n        for (let t = 0; t < required; ++t)\n            this.addPositional({ name });\n        this.arity.extra = NoLimits;\n    }\n    addProxy({ required = 0 } = {}) {\n        this.addRest({ required });\n        this.arity.proxy = true;\n    }\n    addOption({ names, arity = 0, hidden = false, allowBinding = true }) {\n        this.allOptionNames.push(...names);\n        this.options.push({ names, arity, hidden, allowBinding });\n    }\n    setContext(context) {\n        this.context = context;\n    }\n    usage({ detailed = true } = {}) {\n        const segments = [this.cliOpts.binaryName];\n        if (this.paths.length > 0)\n            segments.push(...this.paths[0]);\n        if (detailed) {\n            for (const { names, arity, hidden } of this.options) {\n                if (hidden)\n                    continue;\n                const args = [];\n                for (let t = 0; t < arity; ++t)\n                    args.push(` #${t}`);\n                segments.push(`[${names.join(`,`)}${args.join(``)}]`);\n            }\n            segments.push(...this.arity.leading.map(name => `<${name}>`));\n            if (this.arity.extra === NoLimits)\n                segments.push(`...`);\n            else\n                segments.push(...this.arity.extra.map(name => `[${name}]`));\n            segments.push(...this.arity.trailing.map(name => `<${name}>`));\n        }\n        return segments.join(` `);\n    }\n    compile() {\n        if (typeof this.context === `undefined`)\n            throw new Error(`Assertion failed: No context attached`);\n        const machine = makeStateMachine();\n        let firstNode = NODE_INITIAL;\n        firstNode = injectNode(machine, makeNode());\n        registerStatic(machine, NODE_INITIAL, START_OF_INPUT, firstNode, [`setCandidateUsage`, this.usage()]);\n        const positionalArgument = this.arity.proxy\n            ? `always`\n            : `isNotOptionLike`;\n        const paths = this.paths.length > 0\n            ? this.paths\n            : [[]];\n        for (const path of paths) {\n            let lastPathNode = firstNode;\n            // We allow options to be specified before the path. Note that we\n            // only do this when there is a path, otherwise there would be\n            // some redundancy with the options attached later.\n            if (path.length > 0) {\n                const optionPathNode = injectNode(machine, makeNode());\n                registerShortcut(machine, lastPathNode, optionPathNode);\n                this.registerOptions(machine, optionPathNode);\n                lastPathNode = optionPathNode;\n            }\n            for (let t = 0; t < path.length; ++t) {\n                const nextPathNode = injectNode(machine, makeNode());\n                registerStatic(machine, lastPathNode, path[t], nextPathNode, `pushPath`);\n                lastPathNode = nextPathNode;\n            }\n            if (this.arity.leading.length > 0 || !this.arity.proxy) {\n                const helpNode = injectNode(machine, makeNode());\n                registerDynamic(machine, lastPathNode, `isHelp`, helpNode, [`useHelp`, this.cliIndex]);\n                registerStatic(machine, helpNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, HELP_COMMAND_INDEX]);\n                this.registerOptions(machine, lastPathNode);\n            }\n            if (this.arity.leading.length > 0)\n                registerStatic(machine, lastPathNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n            let lastLeadingNode = lastPathNode;\n            for (let t = 0; t < this.arity.leading.length; ++t) {\n                const nextLeadingNode = injectNode(machine, makeNode());\n                if (!this.arity.proxy)\n                    this.registerOptions(machine, nextLeadingNode);\n                if (this.arity.trailing.length > 0 || t + 1 !== this.arity.leading.length)\n                    registerStatic(machine, nextLeadingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n                registerDynamic(machine, lastLeadingNode, `isNotOptionLike`, nextLeadingNode, `pushPositional`);\n                lastLeadingNode = nextLeadingNode;\n            }\n            let lastExtraNode = lastLeadingNode;\n            if (this.arity.extra === NoLimits || this.arity.extra.length > 0) {\n                const extraShortcutNode = injectNode(machine, makeNode());\n                registerShortcut(machine, lastLeadingNode, extraShortcutNode);\n                if (this.arity.extra === NoLimits) {\n                    const extraNode = injectNode(machine, makeNode());\n                    if (!this.arity.proxy)\n                        this.registerOptions(machine, extraNode);\n                    registerDynamic(machine, lastLeadingNode, positionalArgument, extraNode, `pushExtra`);\n                    registerDynamic(machine, extraNode, positionalArgument, extraNode, `pushExtra`);\n                    registerShortcut(machine, extraNode, extraShortcutNode);\n                }\n                else {\n                    for (let t = 0; t < this.arity.extra.length; ++t) {\n                        const nextExtraNode = injectNode(machine, makeNode());\n                        if (!this.arity.proxy)\n                            this.registerOptions(machine, nextExtraNode);\n                        registerDynamic(machine, lastExtraNode, positionalArgument, nextExtraNode, `pushExtra`);\n                        registerShortcut(machine, nextExtraNode, extraShortcutNode);\n                        lastExtraNode = nextExtraNode;\n                    }\n                }\n                lastExtraNode = extraShortcutNode;\n            }\n            if (this.arity.trailing.length > 0)\n                registerStatic(machine, lastExtraNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n            let lastTrailingNode = lastExtraNode;\n            for (let t = 0; t < this.arity.trailing.length; ++t) {\n                const nextTrailingNode = injectNode(machine, makeNode());\n                if (!this.arity.proxy)\n                    this.registerOptions(machine, nextTrailingNode);\n                if (t + 1 < this.arity.trailing.length)\n                    registerStatic(machine, nextTrailingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);\n                registerDynamic(machine, lastTrailingNode, `isNotOptionLike`, nextTrailingNode, `pushPositional`);\n                lastTrailingNode = nextTrailingNode;\n            }\n            registerDynamic(machine, lastTrailingNode, positionalArgument, NODE_ERRORED, [`setError`, `Extraneous positional argument`]);\n            registerStatic(machine, lastTrailingNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, this.cliIndex]);\n        }\n        return {\n            machine,\n            context: this.context,\n        };\n    }\n    registerOptions(machine, node) {\n        registerDynamic(machine, node, [`isOption`, `--`], node, `inhibateOptions`);\n        registerDynamic(machine, node, [`isBatchOption`, this.allOptionNames], node, `pushBatch`);\n        registerDynamic(machine, node, [`isBoundOption`, this.allOptionNames, this.options], node, `pushBound`);\n        registerDynamic(machine, node, [`isUnsupportedOption`, this.allOptionNames], NODE_ERRORED, [`setError`, `Unsupported option name`]);\n        registerDynamic(machine, node, [`isInvalidOption`], NODE_ERRORED, [`setError`, `Invalid option name`]);\n        for (const option of this.options) {\n            const longestName = option.names.reduce((longestName, name) => {\n                return name.length > longestName.length ? name : longestName;\n            }, ``);\n            if (option.arity === 0) {\n                for (const name of option.names) {\n                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], node, `pushTrue`);\n                    if (name.startsWith(`--`)) {\n                        registerDynamic(machine, node, [`isNegatedOption`, name, option.hidden || name !== longestName], node, [`pushFalse`, name]);\n                    }\n                }\n            }\n            else if (option.arity === 1) {\n                const argNode = injectNode(machine, makeNode());\n                registerDynamic(machine, argNode, `isNotOptionLike`, node, `setStringValue`);\n                for (const name of option.names) {\n                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], argNode, `pushUndefined`);\n                }\n            }\n            else {\n                throw new Error(`Unsupported option arity (${option.arity})`);\n            }\n        }\n    }\n}\nclass CliBuilder {\n    constructor({ binaryName = `...` } = {}) {\n        this.builders = [];\n        this.opts = { binaryName };\n    }\n    static build(cbs, opts = {}) {\n        return new CliBuilder(opts).commands(cbs).compile();\n    }\n    getBuilderByIndex(n) {\n        if (!(n >= 0 && n < this.builders.length))\n            throw new Error(`Assertion failed: Out-of-bound command index (${n})`);\n        return this.builders[n];\n    }\n    commands(cbs) {\n        for (const cb of cbs)\n            cb(this.command());\n        return this;\n    }\n    command() {\n        const builder = new CommandBuilder(this.builders.length, this.opts);\n        this.builders.push(builder);\n        return builder;\n    }\n    compile() {\n        const machines = [];\n        const contexts = [];\n        for (const builder of this.builders) {\n            const { machine, context } = builder.compile();\n            machines.push(machine);\n            contexts.push(context);\n        }\n        const machine = makeAnyOfMachine(machines);\n        simplifyMachine(machine);\n        return {\n            machine,\n            contexts,\n            process: (input) => {\n                return runMachine(machine, input);\n            },\n            suggest: (input, partial) => {\n                return suggestMachine(machine, input, partial);\n            },\n        };\n    }\n}\n\nconst richFormat = {\n    bold: str => `\\x1b[1m${str}\\x1b[22m`,\n    error: str => `\\x1b[31m\\x1b[1m${str}\\x1b[22m\\x1b[39m`,\n    code: str => `\\x1b[36m${str}\\x1b[39m`,\n};\nconst textFormat = {\n    bold: str => str,\n    error: str => str,\n    code: str => str,\n};\nfunction formatMarkdownish(text, { format, paragraphs }) {\n    // Enforce \\n as newline character\n    text = text.replace(/\\r\\n?/g, `\\n`);\n    // Remove the indentation, since it got messed up with the JS indentation\n    text = text.replace(/^[\\t ]+|[\\t ]+$/gm, ``);\n    // Remove surrounding newlines, since they got added for JS formatting\n    text = text.replace(/^\\n+|\\n+$/g, ``);\n    // List items always end with at least two newlines (in order to not be collapsed)\n    text = text.replace(/^-([^\\n]*?)\\n+/gm, `-$1\\n\\n`);\n    // Single newlines are removed; larger than that are collapsed into one\n    text = text.replace(/\\n(\\n)?\\n*/g, `$1`);\n    if (paragraphs) {\n        text = text.split(/\\n/).map(function (paragraph) {\n            // Does the paragraph starts with a list?\n            let bulletMatch = paragraph.match(/^[*-][\\t ]+(.*)/);\n            if (!bulletMatch)\n                // No, cut the paragraphs into segments of 80 characters\n                return paragraph.match(/(.{1,80})(?: |$)/g).join('\\n');\n            // Yes, cut the paragraphs into segments of 78 characters (to account for the prefix)\n            return bulletMatch[1].match(/(.{1,78})(?: |$)/g).map((line, index) => {\n                return (index === 0 ? `- ` : `  `) + line;\n            }).join(`\\n`);\n        }).join(`\\n\\n`);\n    }\n    // Highlight the code segments\n    text = text.replace(/(`+)((?:.|[\\n])*?)\\1/g, function ($0, $1, $2) {\n        return format.code($1 + $2 + $1);\n    });\n    return text ? text + `\\n` : ``;\n}\n\nclass HelpCommand$1 extends Command {\n    constructor(realCli, contexts) {\n        super();\n        this.realCli = realCli;\n        this.contexts = contexts;\n        this.commands = [];\n    }\n    static from(state, realCli, contexts) {\n        const command = new HelpCommand$1(realCli, contexts);\n        for (const opt of state.options) {\n            switch (opt.name) {\n                case `-c`:\n                    {\n                        command.commands.push(Number(opt.value));\n                    }\n                    break;\n                case `-i`:\n                    {\n                        command.index = Number(opt.value);\n                    }\n                    break;\n            }\n        }\n        return command;\n    }\n    async execute() {\n        let commands = this.commands;\n        if (typeof this.index !== `undefined` && this.index >= 0 && this.index < commands.length)\n            commands = [commands[this.index]];\n        if (commands.length === 1) {\n            this.context.stdout.write(this.realCli.usage(this.contexts[commands[0]].commandClass, { detailed: true }));\n        }\n        else if (commands.length > 1) {\n            this.context.stdout.write(`Multiple commands match your selection:\\n`);\n            this.context.stdout.write(`\\n`);\n            let index = 0;\n            for (const command of this.commands)\n                this.context.stdout.write(this.realCli.usage(this.contexts[command].commandClass, { prefix: `${index++}. `.padStart(5) }));\n            this.context.stdout.write(`\\n`);\n            this.context.stdout.write(`Run again with -h=<index> to see the longer details of any of those commands.\\n`);\n        }\n    }\n}\n\nfunction getDefaultColorSettings() {\n    if (process.env.FORCE_COLOR === `0`)\n        return false;\n    if (process.env.FORCE_COLOR === `1`)\n        return true;\n    if (typeof process.stdout !== `undefined` && process.stdout.isTTY)\n        return true;\n    return false;\n}\n/**\n * @template Context The context shared by all commands. Contexts are a set of values, defined when calling the `run`/`runExit` functions from the CLI instance, that will be made available to the commands via `this.context`.\n */\nclass Cli {\n    constructor({ binaryLabel, binaryName: binaryNameOpt = `...`, binaryVersion, enableColors = getDefaultColorSettings() } = {}) {\n        this.registrations = new Map();\n        this.builder = new CliBuilder({ binaryName: binaryNameOpt });\n        this.binaryLabel = binaryLabel;\n        this.binaryName = binaryNameOpt;\n        this.binaryVersion = binaryVersion;\n        this.enableColors = enableColors;\n    }\n    /**\n     * Creates a new Cli and registers all commands passed as parameters.\n     *\n     * @param commandClasses The Commands to register\n     * @returns The created `Cli` instance\n     */\n    static from(commandClasses) {\n        const cli = new Cli();\n        for (const commandClass of commandClasses)\n            cli.register(commandClass);\n        return cli;\n    }\n    /**\n     * Registers a command inside the CLI.\n     */\n    register(commandClass) {\n        const commandBuilder = this.builder.command();\n        this.registrations.set(commandClass, commandBuilder.cliIndex);\n        const { definitions } = commandClass.resolveMeta(commandClass.prototype);\n        for (const definition of definitions)\n            definition(commandBuilder);\n        commandBuilder.setContext({\n            commandClass,\n        });\n    }\n    process(input) {\n        const { contexts, process } = this.builder.compile();\n        const state = process(input);\n        switch (state.selectedIndex) {\n            case HELP_COMMAND_INDEX:\n                {\n                    return HelpCommand$1.from(state, this, contexts);\n                }\n            default:\n                {\n                    const { commandClass } = contexts[state.selectedIndex];\n                    const command = new commandClass();\n                    command.path = state.path;\n                    const { transformers } = commandClass.resolveMeta(commandClass.prototype);\n                    for (const transformer of transformers)\n                        transformer(state, command);\n                    return command;\n                }\n        }\n    }\n    async run(input, context) {\n        let command;\n        if (!Array.isArray(input)) {\n            command = input;\n        }\n        else {\n            try {\n                command = this.process(input);\n            }\n            catch (error) {\n                context.stdout.write(this.error(error));\n                return 1;\n            }\n        }\n        if (command.help) {\n            context.stdout.write(this.usage(command, { detailed: true }));\n            return 0;\n        }\n        command.context = context;\n        command.cli = {\n            binaryLabel: this.binaryLabel,\n            binaryName: this.binaryName,\n            binaryVersion: this.binaryVersion,\n            definitions: () => this.definitions(),\n            error: (error, opts) => this.error(error, opts),\n            process: input => this.process(input),\n            run: (input, subContext) => this.run(input, Object.assign(Object.assign({}, context), subContext)),\n            usage: (command, opts) => this.usage(command, opts),\n        };\n        let exitCode;\n        try {\n            exitCode = await command.validateAndExecute();\n        }\n        catch (error) {\n            context.stdout.write(this.error(error, { command }));\n            return 1;\n        }\n        return exitCode;\n    }\n    /**\n     * Runs a command and exits the current `process` with the exit code returned by the command.\n     *\n     * @param input An array containing the name of the command and its arguments.\n     *\n     * @example\n     * cli.runExit(process.argv.slice(2), Cli.defaultContext)\n     */\n    async runExit(input, context) {\n        process.exitCode = await this.run(input, context);\n    }\n    suggest(input, partial) {\n        const { contexts, process, suggest } = this.builder.compile();\n        return suggest(input, partial);\n    }\n    definitions({ colored = false } = {}) {\n        const data = [];\n        for (const [commandClass, number] of this.registrations) {\n            if (typeof commandClass.usage === `undefined`)\n                continue;\n            const path = this.getUsageByIndex(number, { detailed: false });\n            const usage = this.getUsageByIndex(number, { detailed: true });\n            const category = typeof commandClass.usage.category !== `undefined`\n                ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })\n                : undefined;\n            const description = typeof commandClass.usage.description !== `undefined`\n                ? formatMarkdownish(commandClass.usage.description, { format: this.format(colored), paragraphs: false })\n                : undefined;\n            const details = typeof commandClass.usage.details !== `undefined`\n                ? formatMarkdownish(commandClass.usage.details, { format: this.format(colored), paragraphs: true })\n                : undefined;\n            const examples = typeof commandClass.usage.examples !== `undefined`\n                ? commandClass.usage.examples.map(([label, cli]) => [formatMarkdownish(label, { format: this.format(colored), paragraphs: false }), cli.replace(/\\$0/g, this.binaryName)])\n                : undefined;\n            data.push({ path, usage, category, description, details, examples });\n        }\n        return data;\n    }\n    usage(command = null, { colored, detailed = false, prefix = `$ ` } = {}) {\n        // @ts-ignore\n        const commandClass = command !== null && typeof command.getMeta === `undefined`\n            ? command.constructor\n            : command;\n        let result = ``;\n        if (!commandClass) {\n            const commandsByCategories = new Map();\n            for (const [commandClass, number] of this.registrations.entries()) {\n                if (typeof commandClass.usage === `undefined`)\n                    continue;\n                const category = typeof commandClass.usage.category !== `undefined`\n                    ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })\n                    : null;\n                let categoryCommands = commandsByCategories.get(category);\n                if (typeof categoryCommands === `undefined`)\n                    commandsByCategories.set(category, categoryCommands = []);\n                const usage = this.getUsageByIndex(number);\n                categoryCommands.push({ commandClass, usage });\n            }\n            const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {\n                if (a === null)\n                    return -1;\n                if (b === null)\n                    return +1;\n                return a.localeCompare(b, `en`, { usage: `sort`, caseFirst: `upper` });\n            });\n            const hasLabel = typeof this.binaryLabel !== `undefined`;\n            const hasVersion = typeof this.binaryVersion !== `undefined`;\n            if (hasLabel || hasVersion) {\n                if (hasLabel && hasVersion)\n                    result += `${this.format(colored).bold(`${this.binaryLabel} - ${this.binaryVersion}`)}\\n\\n`;\n                else if (hasLabel)\n                    result += `${this.format(colored).bold(`${this.binaryLabel}`)}\\n`;\n                else\n                    result += `${this.format(colored).bold(`${this.binaryVersion}`)}\\n`;\n                result += `  ${this.format(colored).bold(prefix)}${this.binaryName} <command>\\n`;\n            }\n            else {\n                result += `${this.format(colored).bold(prefix)}${this.binaryName} <command>\\n`;\n            }\n            for (let categoryName of categoryNames) {\n                const commands = commandsByCategories.get(categoryName).slice().sort((a, b) => {\n                    return a.usage.localeCompare(b.usage, `en`, { usage: `sort`, caseFirst: `upper` });\n                });\n                const header = categoryName !== null\n                    ? categoryName.trim()\n                    : `Where <command> is one of`;\n                result += `\\n`;\n                result += `${this.format(colored).bold(`${header}:`)}\\n`;\n                for (let { commandClass, usage } of commands) {\n                    const doc = commandClass.usage.description || `undocumented`;\n                    result += `\\n`;\n                    result += `  ${this.format(colored).bold(usage)}\\n`;\n                    result += `    ${formatMarkdownish(doc, { format: this.format(colored), paragraphs: false })}`;\n                }\n            }\n            result += `\\n`;\n            result += formatMarkdownish(`You can also print more details about any of these commands by calling them after adding the \\`-h,--help\\` flag right after the command name.`, { format: this.format(colored), paragraphs: true });\n        }\n        else {\n            if (!detailed) {\n                result += `${this.format(colored).bold(prefix)}${this.getUsageByRegistration(commandClass)}\\n`;\n            }\n            else {\n                const { description = ``, details = ``, examples = [], } = commandClass.usage || {};\n                if (description !== ``) {\n                    result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false }).replace(/^./, $0 => $0.toUpperCase());\n                    result += `\\n`;\n                }\n                if (details !== `` || examples.length > 0) {\n                    result += `${this.format(colored).bold(`Usage:`)}\\n`;\n                    result += `\\n`;\n                }\n                result += `${this.format(colored).bold(prefix)}${this.getUsageByRegistration(commandClass)}\\n`;\n                if (details !== ``) {\n                    result += `\\n`;\n                    result += `${this.format(colored).bold(`Details:`)}\\n`;\n                    result += `\\n`;\n                    result += formatMarkdownish(details, { format: this.format(colored), paragraphs: true });\n                }\n                if (examples.length > 0) {\n                    result += `\\n`;\n                    result += `${this.format(colored).bold(`Examples:`)}\\n`;\n                    for (let [description, example] of examples) {\n                        result += `\\n`;\n                        result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false });\n                        result += example\n                            .replace(/^/m, `  ${this.format(colored).bold(prefix)}`)\n                            .replace(/\\$0/g, this.binaryName)\n                            + `\\n`;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    error(error, { colored, command = null } = {}) {\n        if (!(error instanceof Error))\n            error = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(error)})`);\n        let result = ``;\n        let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);\n        if (name === `Error`)\n            name = `Internal Error`;\n        result += `${this.format(colored).error(name)}: ${error.message}\\n`;\n        // @ts-ignore\n        const meta = error.clipanion;\n        if (typeof meta !== `undefined`) {\n            if (meta.type === `usage`) {\n                result += `\\n`;\n                result += this.usage(command);\n            }\n        }\n        else {\n            if (error.stack) {\n                result += `${error.stack.replace(/^.*\\n/, ``)}\\n`;\n            }\n        }\n        return result;\n    }\n    getUsageByRegistration(klass, opts) {\n        const index = this.registrations.get(klass);\n        if (typeof index === `undefined`)\n            throw new Error(`Assertion failed: Unregistered command`);\n        return this.getUsageByIndex(index, opts);\n    }\n    getUsageByIndex(n, opts) {\n        return this.builder.getBuilderByIndex(n).usage(opts);\n    }\n    format(colored = this.enableColors) {\n        return colored ? richFormat : textFormat;\n    }\n}\n/**\n * The default context of the CLI.\n *\n * Contains the stdio of the current `process`.\n */\nCli.defaultContext = {\n    stdin: process.stdin,\n    stdout: process.stdout,\n    stderr: process.stderr,\n};\n\nCommand.Entries.Help = HelpCommand;\nCommand.Entries.Version = VersionCommand;\n\nexports.Cli = Cli;\nexports.Command = Command;\nexports.UsageError = UsageError;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/clipanion-npm-2.4.2-13e4b031fe-4a8aa1c126.zip/node_modules/clipanion/lib/index.js?");

/***/ }),

/***/ "./.yarn/cache/clone-deep-npm-4.0.1-70adab92c8-b0146d66ca.zip/node_modules/clone-deep/index.js":
/*!*****************************************************************************************************!*\
  !*** ./.yarn/cache/clone-deep-npm-4.0.1-70adab92c8-b0146d66ca.zip/node_modules/clone-deep/index.js ***!
  \*****************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Module dependenices\n */\n\nconst clone = __webpack_require__(/*! shallow-clone */ \"./.yarn/cache/shallow-clone-npm-3.0.1-dab5873d0d-e329e054c2.zip/node_modules/shallow-clone/index.js\");\nconst typeOf = __webpack_require__(/*! kind-of */ \"./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-5de5d65777.zip/node_modules/kind-of/index.js\");\nconst isPlainObject = __webpack_require__(/*! is-plain-object */ \"./.yarn/cache/is-plain-object-npm-2.0.4-da3265d804-2f32322673.zip/node_modules/is-plain-object/index.js\");\n\nfunction cloneDeep(val, instanceClone) {\n  switch (typeOf(val)) {\n    case 'object':\n      return cloneObjectDeep(val, instanceClone);\n    case 'array':\n      return cloneArrayDeep(val, instanceClone);\n    default: {\n      return clone(val);\n    }\n  }\n}\n\nfunction cloneObjectDeep(val, instanceClone) {\n  if (typeof instanceClone === 'function') {\n    return instanceClone(val);\n  }\n  if (instanceClone || isPlainObject(val)) {\n    const res = new val.constructor();\n    for (let key in val) {\n      res[key] = cloneDeep(val[key], instanceClone);\n    }\n    return res;\n  }\n  return val;\n}\n\nfunction cloneArrayDeep(val, instanceClone) {\n  const res = new val.constructor(val.length);\n  for (let i = 0; i < val.length; i++) {\n    res[i] = cloneDeep(val[i], instanceClone);\n  }\n  return res;\n}\n\n/**\n * Expose `cloneDeep`\n */\n\nmodule.exports = cloneDeep;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/clone-deep-npm-4.0.1-70adab92c8-b0146d66ca.zip/node_modules/clone-deep/index.js?");

/***/ }),

/***/ "./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js":
/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js ***!
  \*****************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = __webpack_require__(/*! color-name */ \"./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js?");

/***/ }),

/***/ "./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js ***!
  \***********************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const conversions = __webpack_require__(/*! ./conversions */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js\");\nconst route = __webpack_require__(/*! ./route */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js\");\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/index.js?");

/***/ }),

/***/ "./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js ***!
  \***********************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const conversions = __webpack_require__(/*! ./conversions */ \"./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/conversions.js\");\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/color-convert-npm-2.0.1-79730e935b-3d5d8a011a.zip/node_modules/color-convert/route.js?");

/***/ }),

/***/ "./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js":
/*!*****************************************************************************************************!*\
  !*** ./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js ***!
  \*****************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/color-name-npm-1.1.4-025792b0ea-3e1c9a4dee.zip/node_modules/color-name/index.js?");

/***/ }),

/***/ "./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js":
/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js ***!
  \*************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js?");

/***/ }),

/***/ "./.yarn/cache/is-plain-object-npm-2.0.4-da3265d804-2f32322673.zip/node_modules/is-plain-object/index.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/is-plain-object-npm-2.0.4-da3265d804-2f32322673.zip/node_modules/is-plain-object/index.js ***!
  \***************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nvar isObject = __webpack_require__(/*! isobject */ \"./.yarn/cache/isobject-npm-3.0.1-8145901fd2-b537a9ccdd.zip/node_modules/isobject/index.js\");\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/is-plain-object-npm-2.0.4-da3265d804-2f32322673.zip/node_modules/is-plain-object/index.js?");

/***/ }),

/***/ "./.yarn/cache/isobject-npm-3.0.1-8145901fd2-b537a9ccdd.zip/node_modules/isobject/index.js":
/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/isobject-npm-3.0.1-8145901fd2-b537a9ccdd.zip/node_modules/isobject/index.js ***!
  \*************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/isobject-npm-3.0.1-8145901fd2-b537a9ccdd.zip/node_modules/isobject/index.js?");

/***/ }),

/***/ "./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-5de5d65777.zip/node_modules/kind-of/index.js":
/*!***********************************************************************************************!*\
  !*** ./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-5de5d65777.zip/node_modules/kind-of/index.js ***!
  \***********************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

eval("var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-5de5d65777.zip/node_modules/kind-of/index.js?");

/***/ }),

/***/ "./.yarn/cache/shallow-clone-npm-3.0.1-dab5873d0d-e329e054c2.zip/node_modules/shallow-clone/index.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/shallow-clone-npm-3.0.1-dab5873d0d-e329e054c2.zip/node_modules/shallow-clone/index.js ***!
  \***********************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * shallow-clone <https://github.com/jonschlinkert/shallow-clone>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nconst valueOf = Symbol.prototype.valueOf;\nconst typeOf = __webpack_require__(/*! kind-of */ \"./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-5de5d65777.zip/node_modules/kind-of/index.js\");\n\nfunction clone(val, deep) {\n  switch (typeOf(val)) {\n    case 'array':\n      return val.slice();\n    case 'object':\n      return Object.assign({}, val);\n    case 'date':\n      return new val.constructor(Number(val));\n    case 'map':\n      return new Map(val);\n    case 'set':\n      return new Set(val);\n    case 'buffer':\n      return cloneBuffer(val);\n    case 'symbol':\n      return cloneSymbol(val);\n    case 'arraybuffer':\n      return cloneArrayBuffer(val);\n    case 'float32array':\n    case 'float64array':\n    case 'int16array':\n    case 'int32array':\n    case 'int8array':\n    case 'uint16array':\n    case 'uint32array':\n    case 'uint8clampedarray':\n    case 'uint8array':\n      return cloneTypedArray(val);\n    case 'regexp':\n      return cloneRegExp(val);\n    case 'error':\n      return Object.create(val);\n    default: {\n      return val;\n    }\n  }\n}\n\nfunction cloneRegExp(val) {\n  const flags = val.flags !== void 0 ? val.flags : (/\\w+$/.exec(val) || void 0);\n  const re = new val.constructor(val.source, flags);\n  re.lastIndex = val.lastIndex;\n  return re;\n}\n\nfunction cloneArrayBuffer(val) {\n  const res = new val.constructor(val.byteLength);\n  new Uint8Array(res).set(new Uint8Array(val));\n  return res;\n}\n\nfunction cloneTypedArray(val, deep) {\n  return new val.constructor(val.buffer, val.byteOffset, val.length);\n}\n\nfunction cloneBuffer(val) {\n  const len = val.length;\n  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);\n  val.copy(buf);\n  return buf;\n}\n\nfunction cloneSymbol(val) {\n  return valueOf ? Object(valueOf.call(val)) : {};\n}\n\n/**\n * Expose `clone`\n */\n\nmodule.exports = clone;\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/shallow-clone-npm-3.0.1-dab5873d0d-e329e054c2.zip/node_modules/shallow-clone/index.js?");

/***/ }),

/***/ "./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js ***!
  \*************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"./.yarn/cache/has-flag-npm-4.0.0-32af9f0536-2e5391139d.zip/node_modules/has-flag/index.js\");\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/supports-color-npm-7.1.0-df2ba1e338-6130f36b2a.zip/node_modules/supports-color/index.js?");

/***/ }),

/***/ "./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/index.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/index.js ***!
  \****************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nexports.customizeObject = exports.customizeArray = exports.unique = exports.mergeWithCustomize = exports.merge = void 0;\nvar wildcard_1 = __importDefault(__webpack_require__(/*! wildcard */ \"./.yarn/cache/wildcard-npm-2.0.0-baedca033a-207baede4d.zip/node_modules/wildcard/index.js\"));\nvar merge_with_1 = __importDefault(__webpack_require__(/*! ./merge-with */ \"./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/merge-with.js\"));\nvar join_arrays_1 = __importDefault(__webpack_require__(/*! ./join-arrays */ \"./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/join-arrays.js\"));\nvar unique_1 = __importDefault(__webpack_require__(/*! ./unique */ \"./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/unique.js\"));\nexports.unique = unique_1[\"default\"];\nvar types_1 = __webpack_require__(/*! ./types */ \"./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/types.js\");\nfunction merge(firstConfiguration) {\n    var configurations = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        configurations[_i - 1] = arguments[_i];\n    }\n    return mergeWithCustomize({}).apply(void 0, __spread([firstConfiguration], configurations));\n}\nexports.merge = merge;\nfunction mergeWithCustomize(options) {\n    return function mergeWithOptions(firstConfiguration) {\n        var configurations = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            configurations[_i - 1] = arguments[_i];\n        }\n        // No configuration at all\n        if (!firstConfiguration) {\n            return {};\n        }\n        // @ts-ignore\n        if (firstConfiguration.then) {\n            throw new TypeError(\"Promises are not supported\");\n        }\n        if (configurations.length === 0) {\n            if (Array.isArray(firstConfiguration)) {\n                // Empty array\n                if (firstConfiguration.length === 0) {\n                    return {};\n                }\n                // @ts-ignore\n                if (firstConfiguration[0].then) {\n                    throw new TypeError(\"Promises are not supported\");\n                }\n                return merge_with_1[\"default\"](firstConfiguration, join_arrays_1[\"default\"](options));\n            }\n            return firstConfiguration;\n        }\n        return merge_with_1[\"default\"]([firstConfiguration].concat(configurations), join_arrays_1[\"default\"](options));\n    };\n}\nexports.mergeWithCustomize = mergeWithCustomize;\nfunction customizeArray(rules) {\n    return function (a, b, key) {\n        var match = Object.keys(rules).find(function (rule) { return wildcard_1[\"default\"](rule, key); }) || \"\";\n        switch (rules[match]) {\n            case types_1.CustomizeRule.Prepend:\n                return __spread(b, a);\n            case types_1.CustomizeRule.Replace:\n                return b;\n            case types_1.CustomizeRule.Append:\n            default:\n                return __spread(a, b);\n        }\n    };\n}\nexports.customizeArray = customizeArray;\nfunction customizeObject(rules) {\n    return function (a, b, key) {\n        switch (rules[key]) {\n            case types_1.CustomizeRule.Prepend:\n                return merge_with_1[\"default\"]([b, a], join_arrays_1[\"default\"]());\n            case types_1.CustomizeRule.Replace:\n                return b;\n            case types_1.CustomizeRule.Append:\n                return merge_with_1[\"default\"]([a, b], join_arrays_1[\"default\"]());\n        }\n    };\n}\nexports.customizeObject = customizeObject;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/index.js?");

/***/ }),

/***/ "./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/join-arrays.js":
/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/join-arrays.js ***!
  \**********************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nvar clone_deep_1 = __importDefault(__webpack_require__(/*! clone-deep */ \"./.yarn/cache/clone-deep-npm-4.0.1-70adab92c8-b0146d66ca.zip/node_modules/clone-deep/index.js\"));\nvar merge_with_1 = __importDefault(__webpack_require__(/*! ./merge-with */ \"./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/merge-with.js\"));\nvar isArray = Array.isArray;\nfunction joinArrays(_a) {\n    var _b = _a === void 0 ? {} : _a, customizeArray = _b.customizeArray, customizeObject = _b.customizeObject, key = _b.key;\n    return function _joinArrays(a, b, k) {\n        var newKey = key ? key + \".\" + k : k;\n        if (isFunction(a) && isFunction(b)) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return _joinArrays(a.apply(void 0, __spread(args)), b.apply(void 0, __spread(args)), k);\n            };\n        }\n        if (isArray(a) && isArray(b)) {\n            var customResult = customizeArray && customizeArray(a, b, newKey);\n            return customResult || __spread(a, b);\n        }\n        if (isPlainObject(a) && isPlainObject(b)) {\n            var customResult = customizeObject && customizeObject(a, b, newKey);\n            return (customResult ||\n                merge_with_1[\"default\"]([a, b], joinArrays({\n                    customizeArray: customizeArray,\n                    customizeObject: customizeObject,\n                    key: newKey\n                })));\n        }\n        if (isPlainObject(b)) {\n            return clone_deep_1[\"default\"](b);\n        }\n        if (isArray(b)) {\n            return __spread(b);\n        }\n        return b;\n    };\n}\nexports.default = joinArrays;\n// https://stackoverflow.com/a/7356528/228885\nfunction isFunction(functionToCheck) {\n    return (functionToCheck && {}.toString.call(functionToCheck) === \"[object Function]\");\n}\nfunction isPlainObject(a) {\n    return typeof a === \"object\";\n}\n//# sourceMappingURL=join-arrays.js.map\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/join-arrays.js?");

/***/ }),

/***/ "./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/merge-with.js":
/*!*********************************************************************************************************************!*\
  !*** ./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/merge-with.js ***!
  \*********************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nexports.__esModule = true;\nfunction mergeWith(objects, customizer) {\n    var _a = __read(objects), first = _a[0], rest = _a.slice(1);\n    var ret = first;\n    rest.forEach(function (a) {\n        ret = mergeTo(ret, a, customizer);\n    });\n    return ret;\n}\nfunction mergeTo(a, b, customizer) {\n    var ret = {};\n    Object.keys(a)\n        .concat(Object.keys(b))\n        .forEach(function (k) {\n        var v = customizer(a[k], b[k], k);\n        ret[k] = typeof v === \"undefined\" ? a[k] : v;\n    });\n    return ret;\n}\nexports.default = mergeWith;\n//# sourceMappingURL=merge-with.js.map\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/merge-with.js?");

/***/ }),

/***/ "./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/types.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/types.js ***!
  \****************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.__esModule = true;\nexports.CustomizeRule = void 0;\nvar CustomizeRule;\n(function (CustomizeRule) {\n    CustomizeRule[\"Append\"] = \"append\";\n    CustomizeRule[\"Prepend\"] = \"prepend\";\n    CustomizeRule[\"Replace\"] = \"replace\";\n})(CustomizeRule = exports.CustomizeRule || (exports.CustomizeRule = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/types.js?");

/***/ }),

/***/ "./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/unique.js":
/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/unique.js ***!
  \*****************************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nexports.__esModule = true;\nfunction mergeUnique(key, uniques, getter) {\n    return function (a, b, k) {\n        return k === key && __spread(difference(a, b, function (item) { return uniques.indexOf(getter(item)); }), b);\n    };\n}\nfunction difference(a, b, cb) {\n    var ret = a.filter(function (v, i) {\n        var foundA = cb(v);\n        var foundB = cb(b[i] || {});\n        if (foundA >= 0 && foundB >= 0) {\n            return foundA !== foundB;\n        }\n        return true;\n    });\n    return ret;\n}\nexports.default = mergeUnique;\n//# sourceMappingURL=unique.js.map\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/webpack-merge-npm-5.0.9-c8179aa67c-7d31955ae5.zip/node_modules/webpack-merge/dist/unique.js?");

/***/ }),

/***/ "./.yarn/cache/wildcard-npm-2.0.0-baedca033a-207baede4d.zip/node_modules/wildcard/index.js":
/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/wildcard-npm-2.0.0-baedca033a-207baede4d.zip/node_modules/wildcard/index.js ***!
  \*************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("/* jshint node: true */\n\n\nvar REGEXP_PARTS = /(\\*|\\?)/g;\n\n/**\n  # wildcard\n\n  Very simple wildcard matching, which is designed to provide the same\n  functionality that is found in the\n  [eve](https://github.com/adobe-webplatform/eve) eventing library.\n\n  ## Usage\n\n  It works with strings:\n\n  <<< examples/strings.js\n\n  Arrays:\n\n  <<< examples/arrays.js\n\n  Objects (matching against keys):\n\n  <<< examples/objects.js\n\n  ## Alternative Implementations\n\n  - <https://github.com/isaacs/node-glob>\n\n    Great for full file-based wildcard matching.\n\n  - <https://github.com/sindresorhus/matcher>\n\n     A well cared for and loved JS wildcard matcher.\n**/\n\nfunction WildcardMatcher(text, separator) {\n  this.text = text = text || '';\n  this.hasWild = text.indexOf('*') >= 0;\n  this.separator = separator;\n  this.parts = text.split(separator).map(this.classifyPart.bind(this));\n}\n\nWildcardMatcher.prototype.match = function(input) {\n  var matches = true;\n  var parts = this.parts;\n  var ii;\n  var partsCount = parts.length;\n  var testParts;\n\n  if (typeof input == 'string' || input instanceof String) {\n    if (!this.hasWild && this.text != input) {\n      matches = false;\n    } else {\n      testParts = (input || '').split(this.separator);\n      for (ii = 0; matches && ii < partsCount; ii++) {\n        if (parts[ii] === '*')  {\n          continue;\n        } else if (ii < testParts.length) {\n          matches = parts[ii] instanceof RegExp\n            ? parts[ii].test(testParts[ii])\n            : parts[ii] === testParts[ii];\n        } else {\n          matches = false;\n        }\n      }\n\n      // If matches, then return the component parts\n      matches = matches && testParts;\n    }\n  }\n  else if (typeof input.splice == 'function') {\n    matches = [];\n\n    for (ii = input.length; ii--; ) {\n      if (this.match(input[ii])) {\n        matches[matches.length] = input[ii];\n      }\n    }\n  }\n  else if (typeof input == 'object') {\n    matches = {};\n\n    for (var key in input) {\n      if (this.match(key)) {\n        matches[key] = input[key];\n      }\n    }\n  }\n\n  return matches;\n};\n\nWildcardMatcher.prototype.classifyPart = function(part) {\n  // in the event that we have been provided a part that is not just a wildcard\n  // then turn this into a regular expression for matching purposes\n  if (part === '*') {\n    return part;\n  } else if (part.indexOf('*') >= 0 || part.indexOf('?') >= 0) {\n    return new RegExp(part.replace(REGEXP_PARTS, '\\.$1'));\n  }\n\n  return part;\n};\n\nmodule.exports = function(text, test, separator) {\n  var matcher = new WildcardMatcher(text, separator || /[\\/\\.]/);\n  if (typeof test != 'undefined') {\n    return matcher.match(test);\n  }\n\n  return matcher;\n};\n\n\n//# sourceURL=webpack://@noderalis/monorepo/./.yarn/cache/wildcard-npm-2.0.0-baedca033a-207baede4d.zip/node_modules/wildcard/index.js?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22fs%22?");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"module\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22module%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22path%22?");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"tty\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22tty%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22util%22?");

/***/ }),

/***/ "webpack":
/*!**************************!*\
  !*** external "webpack" ***!
  \**************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"webpack\");\n\n//# sourceURL=webpack://@noderalis/monorepo/external_%22webpack%22?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./packages/noderalis-builder/sources/index.ts");
/******/ })()
;